<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[win：cmd脚本每天定期清理文件夹]]></title>
    <url>%2Fp%2F2112220982%2F</url>
    <content type="text"><![CDATA[工作中有这样一个场景，需要一台Windows电脑24小时地运行一个程序。微信某个群需要频繁发送文件，因此会在微信的文件夹下留存大量文件，并且文件后缀加到三四十。这就导致群里微信的使用者很难找到自己想要的文件。因此使用了cmd脚本+任务计划的方式来每天零点清理该微信的文件。清理脚本12set month=%date:~0,4%-%date:~5,2%del /Q "C:\Users\remy\Documents\WeChat Files\wxid_37xk1ypk5u8y12\FileStorage\File\%month%"⚠️此法会直接删除文件，而不会把文件留存在回收站。因此不适合有文件需要留存的场景。使用win记事本新建txt文件，将上面的内容黏贴进去，然后另存为，将编码改为ANSI。重命名为delete-file.bat。系统可能会跳出如下提示：点击是即可。这时，你就得到了一个可以运行的批处理文件。定时任务使用win自带的任务计划程序。在搜索程序中搜索该程序：菜单栏选择操作-创建任务，自定义任务的名字。设置触发条件为按计划每天执行，图里我把时间设为里每天一点。设置操作为启动刚刚编辑的bat文件，在浏览里选中bat文件的路径。点击确认后即创建完成。完成后可在任务计划程序库里找到刚刚新建的任务，点击任务右键运行立即执行。程序会在每天1点清空微信文件夹收发的文件。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win：自定义cmd脚本及任务计划检查断网并自动重启]]></title>
    <url>%2Fp%2F2112220981%2F</url>
    <content type="text"><![CDATA[工作中有这样一个场景，需要一台Windows电脑24小时地运行一个程序。因公司要求，电脑不能连Wi-Fi，只能连交换机出来的网线。但是我们办公室的交换机比较老旧，电脑网络经常断连，导致程序无法正常运行。问题解决起来也简单，重置一下电脑网络就能恢复。但是多次断网出现在晚上，运维很不方便。因此，还是需要一个自动检测断网并重置网络的程序来处理。百度了一圈，最后采用了cmd脚本+任务计划的方式来实现。自动重启脚本脚本大致要实现以下功能：检测当前是否断网；断网时重置网络；不断网时不做任何处理。检测是否断网123456789:begin# ping百度ping www.baidu.com &gt; nul# 获取ping的结果rem echo %errorlevel%# ping失败则跳转到重启部分if %errorlevel% == 1 goto reboot# ping成功则跳转到暂停缓冲区goto loop通过ping百度来判断是否断网；然后echo返回ping结果。%errorlevel% == 1则跳转到reboot；否则跳转到loop。重置网络12345678910:rebootecho %date% %time% 网卡停止中...# 禁用网卡netsh interface set interface "以太网" disabledecho %date% %time% 网卡启动...# 启用网卡netsh interface set interface "以太网" enabledecho %date% %time% 网卡已重新启动# 输出日志echo %date% %time% 网卡已重新启动 &gt;&gt; errorlog.txt通过netsh命令，设置对应网卡名称（比如我的电脑上叫以太网）的网卡，先禁用，再启用，然后保留一份重启时间（也可以不保留）。可以在cmd先测试一下netsh interface set interface &quot;以太网&quot; disabled和netsh interface set interface &quot;以太网&quot; enabled两条命令。⚠️需要cmd右键以管理员方式运行如果运行失败，可能是你电脑上的网卡名称不为以太网，可以通过下面这个命令获取网卡名称：1netsh interface show interface暂停缓冲因为实际上允许一定时间的断网，不需要一直ping，所以一次ping成功后，可以暂停一定时间再进行下次ping。1234:loop# ping本地30秒ping 127.0.0.1 -n 30 &gt; nulgoto begin通过ping本地ip30秒来实现暂停操作，30秒后重新进入begin。创建脚本将上面的命令整合之后得到如下脚本：1234567891011121314151617181920212223@echo offif not "%OS%"=="Windows_NT" exittitle 网络自动检测重启服务echo 网络自动检测重启服务正在运行中...echo 按 Ctrl + C 停止服务:beginping www.baidu.com &gt; nulrem echo %errorlevel%if %errorlevel% == 1 goto rebootgoto loop:rebootecho %date% %time% 网卡停止中...netsh interface set interface "以太网" disabledecho %date% %time% 网卡启动...netsh interface set interface "以太网" enabledecho %date% %time% 网卡已重新启动echo %date% %time% 网卡已重新启动 &gt;&gt; errorlog.txt:loopping 127.0.0.1 -n 30 &gt; nulgoto begin使用win记事本新建txt文件，将上面的内容黏贴进去，然后另存为，将编码改为ANSI。重命名为net-restart.bat。系统可能会跳出如下提示：点击是即可。这时，你就得到了一个可以运行的批处理文件。右键文件，以管理员方式运行。如果服务重启，会将信息打印出来，同时将重启日志追加记录到errorlog.txt内。目录重定位errorlog.txt的默认地址是和bat文件同一个地址，但是以管理员方式运行后，默认路径被更改到了，errorlog.txt也被输出在了那里。若要重新改为bat文件的地址，可使用：1cd /D %~dp0此命令将目录cd到当前目录下。可以通过邮件bat文件，点击编辑进行更改：123456789101112131415161718192021222324252627@echo offif not "%OS%"=="Windows_NT" exittitle 网络自动检测重启服务echo 网络自动检测重启服务正在运行中...echo 当前目录：%cd%echo 变量扩充: %~dp0cd /D %~dp0echo 更改后的目录：%cd%echo 按 Ctrl + C 停止服务:beginping www.baidu.com &gt; nulrem echo %errorlevel%if %errorlevel% == 1 goto rebootgoto loop:rebootecho %date% %time% 网卡停止中...netsh interface set interface "以太网" disabledecho %date% %time% 网卡启动...netsh interface set interface "以太网" enabledecho %date% %time% 网卡已重新启动echo %date% %time% 网卡已重新启动 &gt;&gt; errorlog.txt:loopping 127.0.0.1 -n 30 &gt; nulgoto begin定时任务定时任务使用了win自带的任务计划程序。在搜索程序中搜索该程序：打开，在菜单栏选择操作-创建任务。自定义任务的名字，并设置为管理员权限设置触发条件为开机启动。设置操作为启动刚刚编辑的bat文件，在浏览里选中bat文件的路径。关闭长时间执行自动停止点击确认后，会要求你输入登录密码（因为前面请求了管理员权限）。完成后可在任务计划程序库里找到刚刚新建的任务，点击任务右键运行即可。程序会在每次开机时自动启用，并且避免了总是要打开终端窗口。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring与Spring Boot]]></title>
    <url>%2Fp%2F3216883251%2F</url>
    <content type="text"><![CDATA[先从Spring谈起我们知道Spring是重量级企业开发框架 Enterprise JavaBean（EJB） 的替代品，Spring为企业级Java开发提供了一种相对简单的方法，通过 依赖注入 和 面向切面编程 ，用简单的 Java对象（Plain Old Java Object，POJO） 实现了EJB的功能虽然Spring的组件代码是轻量级的，但它的配置却是重量级的（需要大量XML配置） 。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。尽管如此，我们依旧没能逃脱配置的魔爪。开启某些Spring特性时，比如事务管理和Spring MVC，还是需要用XML或Java进行显式配置。启用第三方库时也需要显式配置，比如基于Thymeleaf的Web视图。配置Servlet和过滤器（比如Spring的DispatcherServlet）同样需要在web.xml或Servlet初始化代码里进行显式配置。组件扫描减少了配置量，Java配置让它看上去简洁不少，但Spring还是需要不少配置。光配置这些XML文件都够我们头疼的了，占用了我们大部分时间和精力。除此之外，相关库的依赖非常让人头疼，不同库之间的版本冲突也非常常见。不过，好消息是：Spring Boot让这一切成为了过去。再来谈谈 Spring Boot最好直白的介绍莫过于官方的介绍：Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”…Most Spring Boot applications need very little Spring configuration.(Spring Boot可以轻松创建独立的生产级基于Spring的应用程序,只要通过 “just run”（可能是run ‘Application’或java -jar 或 tomcat 或 maven插件run 或 shell脚本）便可以运行项目。大部分Spring Boot项目只需要少量的配置即可)简而言之，从本质上来说，Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。优点开发基于 Spring 的应用程序很容易。Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。Spring Boot不需要编写大量样板代码、XML配置和注释。Spring引导应用程序可以很容易地与Spring生态系统集成，如Spring JDBC、Spring ORM、Spring Data、Spring Security等。Spring Boot遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。Spring Boot 应用程序提供嵌入式HTTP服务器，如Tomcat和Jetty，可以轻松地开发和测试web应用程序。（这点很赞！普通运行Java程序的方式就能运行基于Spring Boot web 项目，省事很多）Spring Boot提供命令行接口(CLI)工具，用于开发和测试Spring Boot应用程序，如Java或Groovy。Spring Boot提供了多种插件，可以使用内置工具(如Maven和Gradle)开发和测试Spring Boot应用程序。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解Spring]]></title>
    <url>%2Fp%2F3960214993%2F</url>
    <content type="text"><![CDATA[Spring框架是一个开放源代码的J2EE应用程序框架，由Rod Johnson发起，是针对bean的生命周期进行管理的轻量级容器（lightweight container）。 Spring解决了开发者在J2EE开发中遇到的许多常见的问题，提供了功能强大IOC、AOP及Web MVC等功能。Spring IoC&amp;AOPAOPAOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：AOP思想的实现一般都是基于 代理模式 ，在Java中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。推荐阅读：静态代理、JDK动态代理、CGLIB动态代理讲解 ：我们知道AOP思想的实现一般都是基于 代理模式 ，所以在看下面的文章之前建议先了解一下静态代理以及JDK动态代理、CGLIB动态代理的实现方式。Spring AOP 入门 ：带你入门的一篇文章。这篇文章主要介绍了AOP中的基本概念：5种类型的通知（Before，After，After-returning，After-throwing，Around）；Spring中对AOP的支持：AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，Spring AOP 基于AspectJ注解如何实现AOP ： AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器），可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态植入。至于AspectJ的静态植入，不是本文重点，所以只提一提。探秘Spring AOP（慕课网视频，很不错）:慕课网视频，讲解的很不错，详细且深入spring源码剖析（六）AOP实现原理剖析 :通过源码分析Spring AOP的原理IoCIoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。控制反转,将对象的控制交给第三方IOC容器依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。Spring IOC的初始化过程： [Spring框架]Spring IOC的原理及详解。Spring IOC核心源码学习 :比较简短，推荐阅读。Spring IOC 容器源码分析 :强烈推荐，内容详尽，而且便于阅读。什么是 Spring 框架?Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：https://spring.io/。我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。Spring 官网列出的 Spring 的 6 个特征:核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。Web支持 : Spring MVC和Spring WebFlux Web框架。集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。语言 ：Kotlin，Groovy，动态语言。列举一些重要的Spring模块？下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。Spring Aspects ： 该模块为与AspectJ的集成提供支持。Spring AOP ：提供了面向切面的编程实现。Spring JDBC : Java数据库连接。Spring JMS ：Java消息服务。Spring ORM : 用于支持Hibernate等ORM工具。Object-Relationl Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了 。Spring Web : 为创建Web应用程序提供支持。Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。@RestController vs @ControllerController 返回一个页面单独使用 @Controller 不加 @ResponseBody的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。@RestController 返回JSON 或 XML 形式数据但@RestController只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。@Controller +@ResponseBody 返回JSON 或 XML 形式数据如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用@Controller 并结合@ResponseBody注解，也就是说@Controller +@ResponseBody= @RestController（Spring 4 之后新加的注解）。@ResponseBody 注解的作用是将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。Reference:https://dzone.com/articles/spring-framework-restcontroller-vs-controller（图片来源）https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html?m=1Spring beanSpring 中的 bean 的作用域singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。prototype : 每次请求都会创建一个新的 bean 实例。request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话Spring 中的单例 bean 的线程安全问题大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。常见的有两种解决办法：在Bean对象中尽量避免定义可变的成员变量（不太现实）。在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。@Component 和 @Bean 的区别作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。@Bean注解使用示例：1234567@Configurationpublic class AppConfig &#123; @Bean public TransferService transferService() &#123; return new TransferServiceImpl(); &#125;&#125;上面的代码相当于下面的 xml 配置123&lt;beans&gt; &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;&lt;/beans&gt;下面这个例子是通过 @Component 无法实现的。1234567891011@Beanpublic OneService getService(status) &#123; switch (status) &#123; case 1: return new serviceImpl1(); case 2: return new serviceImpl2(); case 3: return new serviceImpl3(); &#125;&#125;将一个类声明为Spring的 bean 的注解有哪些?我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。Spring 中的 bean 生命周期这部分网上有很多文章都讲到了，下面的内容整理自：https://yemengying.com/2016/07/14/spring-bean-life-cycle/ ，除了这篇文章，再推荐一篇很不错的文章 ：https://www.cnblogs.com/zrtqsk/p/3735273.html 。Bean 容器找到配置文件中 Spring Bean 的定义。Bean 容器利用 Java Reflection API 创建一个Bean的实例。如果涉及到一些属性值 利用 set()方法设置一些属性值。如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r对象的实例。与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。图示：与之比较类似的中文版本:Spring MVC谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。Model1 时代 : 很多学 Java 后端比较晚的朋友可能并没有接触过 Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；Model2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。Spring MVC 的简单原理图如下：SpringMVC 工作原理原理如下图所示： 上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 DispatcherServlet 的作用是接收请求，响应结果。流程说明（重要）：客户端（浏览器）发送请求，直接请求到 DispatcherServlet。DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。ViewResolver 会根据逻辑View 查找实际View。DispaterServlet 把返回的 Model 传给 View（视图渲染）。把 View 返回给请求者（浏览器）Spring 框架中用到了哪些设计模式？关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章《面试官:“谈谈Spring中都用到了那些设计模式?”。》 。工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。代理设计模式 : Spring AOP 功能的实现。单例设计模式 : Spring 中的 Bean 默认都是单例的。模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。……Spring 事务Spring 管理事务的方式编程式事务，在代码中硬编码。(不推荐使用)声明式事务，在配置文件中配置（推荐使用）声明式事务又分为两种：基于XML的声明式事务基于注解的声明式事务Spring 事务中的隔离级别种类TransactionDefinition 接口中定义了五个表示隔离级别的常量：TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。8.3 Spring 事务中哪几种事务传播行为?支持当前事务的情况：TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）不支持当前事务的情况：TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。其他情况：TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。@Transactional(rollbackFor = Exception.class)注解我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。当@Transactional注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。JPA使用JPA在数据库中非持久化一个字段假如我们有有下面一个类：1234567891011121314151617Entity(name="USER")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = "ID") private Long id; @Column(name="USER_NAME") private String userName; @Column(name="PASSWORD") private String password; private String secrect; &#125;如果我们想让secrect 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：12345static String transient1; // not persistent because of staticfinal String transient2 = “Satish”; // not persistent because of finaltransient String transient3; // not persistent because of transient@TransientString transient4; // not persistent because of @Transient一般使用后面两种方式比较多，我个人使用注解的方式比较多。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础补充]]></title>
    <url>%2Fp%2F104474348%2F</url>
    <content type="text"><![CDATA[正确使用equals方法Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。举个例子：1234567// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常String str = null;if (str.equals("SnailClimb")) &#123; ...&#125; else &#123; ..&#125;运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。1"SnailClimb".equals(str);// false不过更推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。1Objects.equals(null,"SnailClimb");// false我们看一下java.util.Objects#equals的源码就知道原因了。1234public static boolean equals(Object a, Object b) &#123; // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。 return (a == b) || (a != null &amp;&amp; a.equals(b));&#125;注意每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中null == null将返回true。不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常这里有一个有意思的点,Null(null).a()(a为类Null的静态方法,会正常执行BigDecimalBigDecimal 的用处《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：12345float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;System.out.println(a);// 0.100000024System.out.println(b);// 0.099999964System.out.println(a == b);// false具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（精度丢失），我们如何解决这个问题呢？一种很常用的方法是：使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。123456BigDecimal a = new BigDecimal("1.0");BigDecimal b = new BigDecimal("0.9");BigDecimal c = new BigDecimal("0.8");BigDecimal x = a.subtract(b);// 0.1BigDecimal y = b.subtract(c);// 0.1System.out.println(x.equals(y));// trueBigDecimal比较大小a.compareTo(b) : 返回 -1 表示小于，0 表示 等于， 1表示 大于。123BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);System.out.println(a.compareTo(b));// 1BigDecimal 保留几位小数通过 setScale()方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。123BigDecimal m = new BigDecimal(&quot;1.255433&quot;);BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);System.out.println(n);// 1.255BigDecimal 的使用注意事项注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。总结BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念基本数据类型与包装数据类型的使用标准Reference:《阿里巴巴Java开发手册》【强制】所有的 POJO 类属性必须使用包装数据类型。【强制】RPC 方法的返回值和参数必须使用包装数据类型。【推荐】所有的局部变量使用基本数据类型。比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.说明 :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE(NullPoniterExpection) 问题，或者入库检查，都由使用者来保证。正例 : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例 : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。RPC方法Remote Procedure Call(远程过程调用)分布式是促使RPC诞生的领域.在分布式系统中,你将以给服务A单独放出来,然后用别的服务B去调用它.这时候,我们会想到A暴露一个类似Restful接口,然后服务B调用这个Restful接口来间接什调用A中的方法.这已经接近RPC了,但是每次这样都需要发出http请求,需要将它改成使用者感知不到的方式.我们可以使用代理模式,最好结合Spring IoC一起使用，通过Spring注入calculator对象，注入时，如果扫描到对象加了@Reference注解，那么就给它生成一个代理对象，将这个代理对象放进容器中。而这个代理对象的内部，就是通过httpClient来实现RPC远程过程调用的。参考:如何给老婆解释什么是RPC实体类POJO(plain old java object)普通的java对象，有别于特殊的java对象(含继承约束等)和EJB。POJO一般只有一系列的属性和相应的get、set方法PO(persistant object)持久化对象，有别于POJO,必须对应数据库中的实体。一个PO对应数据库的一条记录。持久化对象的生命周期与数据库密切相关，只能存在于connection之中，连接关闭后，PO就消失了。PO相对于POJO有诸多不同，比如PO中会有保存数据库entity状态的属性和方法。但是ORM(object-relation mapping)追求的目标是PO和POJO的一致，所以在程序员的日常开发中，都是将POJO作为PO使用，而将POJO转化为PO的功能交给hibernate等框架来实现。DTO(data transfer object)数据传输对象，以前被称为值对象(VO,value object)，作用仅在于在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO并不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。DAO(data access object)数据访问对象。提供访问数据库的抽象接口，或者持久化机制，而不暴露数据库的内部详细信息。DAO提供从程序调用到持久层的匹配。BO(business object)业务对象。主要是将业务逻辑封装为一个对象，该对象可以包含一个或多个其他对象。如，”Principal”(委托人)，有”Name”,”Age”等属性，同时和”Employee”(雇员)有1对多的关系，这个”Principal”就可以作为一个与业务相关的PO。集合Arrays.asList()使用指南Arrays.asList()在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。1234String[] myArray = &#123; "Apple", "Banana", "Orange" &#125;； List&lt;String&gt; myList = Arrays.asList(myArray);//上面两个语句等价于下面一条语句List&lt;String&gt; myList = Arrays.asList("Apple","Banana", "Orange");JDK 源码对于这个方法的说明：123456/** *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。 */ public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125;注意事项传递的数组必须是对象数组，而不是基本类型。Arrays.asList()是泛型方法，传入的对象必须是对象数组。1234567int[] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size());//1System.out.println(myList.get(0));//数组地址值System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsExceptionint [] array=(int[]) myList.get(0);System.out.println(array[0]);//1当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。我们使用包装类型数组就可以解决这个问题。1Integer[] myArray = &#123; 1, 2, 3 &#125;;使用集合的修改方法:add()、remove()、clear()会抛出异常。1234List myList = Arrays.asList(1, 2, 3);myList.add(4);//运行时报错：UnsupportedOperationExceptionmyList.remove(1);//运行时报错：UnsupportedOperationExceptionmyList.clear();//运行时报错：UnsupportedOperationExceptionArrays.asList()将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：Arrays.asList()方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。12List myList = Arrays.asList(1, 2, 3);System.out.println(myList.getClass());//class java.util.Arrays$ArrayList正确的将数组转换为ArrayList1. 自己动手实现（教育目的）123456789//JDK1.5+static &lt;T&gt; List&lt;T&gt; arrayToList(final T[] array) &#123; final List&lt;T&gt; l = new ArrayList&lt;T&gt;(array.length); for (final T s : array) &#123; l.add(s); &#125; return (l);&#125;12Integer [] myArray = &#123; 1, 2, 3 &#125;;System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList2. 最简便的方法(推荐)1List list = new ArrayList&lt;&gt;(Arrays.asList("a", "b", "c"))3. 使用 Java8 的Stream(推荐)12345Integer [] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());4. 使用 Guava(推荐)对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）12List&lt;String&gt; il = ImmutableList.of("string", "elements"); // from varargsList&lt;String&gt; il = ImmutableList.copyOf(aStringArray); // from arrayCollection.toArray()方法使用的坑&amp;如何反转数组该方法是一个泛型方法：T[] toArray(T[] a); 如果toArray方法中没有传递任何参数的话返回的是Object类型数组。123456String [] s= new String[]&#123; "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"&#125;;List&lt;String&gt; list = Arrays.asList(s);Collections.reverse(list);s=list.toArray(new String[0]);//没有指定类型的话会报错由于JVM优化，new String[0]作为Collection.toArray()方法的参数现在使用更好，new String[0]就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：https://shipilev.net/blog/2016/arrays-wisdom-ancients/不要在 foreach 循环里进行元素的 remove/add 操作如果要进行remove操作，可以调用迭代器的 remove方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove/add方法，迭代器都将抛出一个ConcurrentModificationException,这就是单线程状态下产生的 fail-fast 机制。fail-fast 机制 ：多个线程对 fail-fast 集合进行修改的时侯，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。java.util包下面的所有的集合类都是fail-fast的，而java.util.concurrent包下面的所有的类都是fail-safe的。序列化和反序列化序列化把对象转换为字节序列的过程称为对象的序列化。反序列化把字节序列恢复为对象的过程称为对象的反序列化。对象的序列化主要有两种用途：把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；在网络上传送对象的字节序列。使用场景在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些session先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。Java对象的序列化和反序列化JDK类库中的序列化APIjava.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。对象序列化包括如下步骤：创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；通过对象输出流的writeObject()方法写对象。对象反序列化的步骤如下：创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；通过对象输入流的readObject()方法读取对象。serialVersionUID的作用serialVersionUID: 字面意思上是序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量1private static final long serialVersionUID序列化版本ID的真实用途：当实体中增加属性后，文件流中的class和classpath中的class，也就是修改过后的class，不兼容了，处于安全机制考虑，程序抛出了错误，并且拒绝载入。那么如果我们真的有需求要在序列化后添加一个字段或者方法呢？应该怎么办？那就是自己去指定serialVersionUID。在例子中，如果没有指定Person类的serialVersionUID的，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。可以说serialVersionUID是序列化和反序列化之间彼此认识的唯一信物。Q: Java序列化中如果有些字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用transient关键字修饰。transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2Fp%2F4159564062%2F</url>
    <content type="text"><![CDATA[面向对象和面向过程面向过程: 没有面向过程易维护,易复用,易扩展面向对象: 易维护,易复用,易扩展, 可以利用封装继承多态的特性,设计出低耦合的系统,是系统更灵活,更加易于维护Java语言的特点平台无关Java虚拟机实现平台无关面向对象封装继承多态支持多线程C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持网络编程Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便编译与解释并存JVM详见《Java虚拟机》Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。Q: 什么是什么是字节码?采用字节码的好处是什么?在Java中,JVM可以理解的代码就叫字节码(.class),它不面向任何特定的处理器,子面向虚拟机.Java通过字节码的形式,在一定程度上解决了传统痛解释型语言执行效率低的问题,同时有保留了解释型语言可移植的特点.所以Java程序运行比较高效,并且无需重新编译即可在多种不同的操作系统中运行.Java程序从源码到运行一般有以下三步:格外注意.class-&gt;机器码这一步.在这一步JVM类加载器首先加载字节码文件,然后通过解释器逐行解释,这种方式的执行速度会相对比较慢.而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。Java应用程序&amp;小程序Q: 什么是 Java 程序的主类?应用程序和小程序的主类有何不同?一个程序可以有多个类,但是只能有一个主类.在Java程序中,这个主类指包含main()方法的类;而在Java小程序中,这个主类是一个继承自系统类JApplet或Applet的子类(真正的mian()方法在其中).应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类.Q: Java 应用程序与小程序之间有哪些差别?应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main() 方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。字符型常量和字符串常量形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)占内存大小: 字符常量只占2个字节; 字符串常量占若干个字节(至少一个字符结束标志)(注意： char在Java中占两个字节)重载和重写重载(overload)重写(override)发生在父子类中,方法名、参数列表比讯相同,返回值范围≤父类,抛出异常范围≤父类,修饰符范围≥父类;若父类方法访问修饰符为 private 则子类就不能重写该方法// TODO: super封装,继承,多态封装封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。关于继承如下 3 点请记住：子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。子类可以拥有自己属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。String, StringBuffer, StringBuilder可变性因为String类使用final关键字修饰字符数组来保存字符串private final char[] value, 所以String对象是不可变的.而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。123456789abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125;&#125;线程安全性String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的.性能每次对String类型进行改变的时候,都会生成一个新的String对象,然后将指针指向性的对象.StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。对于三者使用的总结：操作少量的数据: 适用String单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer构造方法构造方法的特性名字与类名相同。没有返回值，但不能用void声明构造函数。生成类的对象时自动执行，无需调用。super()Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。Q: 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?帮助值子类做初始化工作.接口和抽象类所有方法在接口中不能有实现(Java8开始接口中可以有默认实现);抽象类可以有非抽象的方法;接口中除了static、final不能有其他修饰符修饰的变量,抽象类则不一定;一个类可以实现多个接口,但是只能实现一个抽象类;接口本身可以通过extends继承多个接口;接口的方法默认是public,抽象方法可以有public、protected和default这些修饰符(为了抽象方法可以被重写,不能用private关键字);从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。成员变量和局部变量从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。==与equals()==它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型\==比较的是值，引用数据类型\==比较的是内存地址)equals()它的作用也是判断两个对象是否相等,但它一般有两种情况“类没有覆盖equals()方法则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。类覆盖了 equals() 方法我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)举例:1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String("ab"); // a 为一个引用 String b = new String("ab"); // b为另一个引用,对象的内容一样 String aa = "ab"; // 放在常量池中 String bb = "ab"; // 从常量池中查找 if (aa == bb) // true System.out.println("aa==bb"); if (a == b) // false，非同一对象 System.out.println("a==b"); if (a.equals(b)) // true System.out.println("aEQb"); if (42 == 42.0) &#123; // true System.out.println("true"); &#125; &#125;&#125;说明:String 中的 equals() 方法是被重写过的，因为 object 的 equals() 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。hashCode和equalshashCode()简介hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）为什么有hashCode()我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。hashCode()与equals()的相关规定如果两个对象相等,则hashcode一定也是相同的两个对象相等,对两个对象分别调用equals()方法都返回true两个对象有相同的hashcode值,他们也不一定是相等的equals()方法被覆盖过,则hashCode()方法也必须被覆盖hashCode()的默认行为是对堆上的对象产生独特值.如果没有重写hashCode(),则该class的两个对象无论如何都不会相等(即使则两个对象指向相同的数据)Java值传递为什么Java只有值传递?首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。线程,程序和进程线程线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。线程的基本状态Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：由上图可以看出:线程创建之后将处于NEW(新建)状态,调用start()方法后开始运行,线程这时候处于READY(可运行)状态.可运行状态的线程获得了cpu时间片之后就处于RUNNING((运行)状态.操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。当线程执行waiting()方法之后,线程进入WAITING(等待)状态.进入等待状态的线程需要依靠其他线程的通知才能返回到运行状态,而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。final, static, super关键字final关键字final关键字主要用在三个地方：变量、方法、类。对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升.现在的Java版本已经不需要使用final方法进行这些优化了,类中所有的private方法都隐式地指定为final。static关键字static 关键字主要有以下四种使用场景：修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。super关键字super关键字用于从子类访问父类的变量和方法。 例如：1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println("number = " + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125;在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。使用 this 和 super 要注意的问题：在构造器中使用 super() 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。this、super不能用在static方法中。简单解释一下：被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。Java异常处理Java异常类层次结构图在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。Error（错误）是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。Exception（异常）是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。Throwable类常用方法public string getMessage():返回异常发生时的详细信息public string toString():返回异常发生时的简要描述public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同public void printStackTrace():在控制台上打印Throwable对象封装的异常信息异常处理总结try 块： 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。catch 块： 用于处理try捕获到的异常。finally 块： 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下,finally块不会被执行:finally语句块第一行发送了异常在前面的代码执行了System.exit(int)已退出程序exit()是带参函数;若该语句在异常语句之后,finally回执行程序所在的线程死亡关闭CPU注意:当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：123456789public static int f(int value) &#123; try &#123; return value * value; &#125; finally &#123; if (value == 2) &#123; return 0; &#125; &#125;&#125;如果调用 f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。Java中的IO流IO流分类按照流的流向分，可以分为输入流和输出流；按照操作单元划分，可以划分为字节流和字符流；按照流的角色划分为节点流和处理流。Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。Q: 既然有了字节流,为什么还要有字符流?问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。BIO,NIO,AIOBIO (Blocking I/O)同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。NIO (New I/O)NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发AIO (Asynchronous I/O)AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程与并发]]></title>
    <url>%2Fp%2F866021247%2F</url>
    <content type="text"><![CDATA[线程与进程进程概念进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。线程概念线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。123456789101112public class MultiThread &#123; public static void main(String[] args) &#123; // 获取 Java 线程管理 MXBean ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息 ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); // 遍历线程信息，仅打印线程 ID 和线程名称信息 for (ThreadInfo threadInfo : threadInfos) &#123; System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName()); &#125; &#125;&#125;上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：12345[5] Attach Listener //添加事件[4] Signal Dispatcher // 分发处理给 JVM 信号的线程[3] Finalizer //调用对象 finalize 方法的线程[2] Reference Handler //清除 reference 线程[1] main //main 线程,程序入口从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。进程和线程的关系从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。总结： 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反下面是该知识点的扩展内容！下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？程序计数器为什么是私有的?程序计数器主要有下面两个作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。虚拟机栈和本地方法栈为什么是私有的?虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。一句话简单了解堆和方法区堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。进程间通信进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息.IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。管道管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。FIFOFIFO，也称为命名管道，它是一种文件类型。FIFO可以在无关的进程之间交换数据，与无名管道不同。FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。消息队列消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。信号量信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。支持信号量组。共享内存共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。并发与并行的区别并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；并行： 单位时间内，多个任务同时执行。多线程先从总体上来说：从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。再深入到计算机底层来探讨：单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。多线程可能带来的问题并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。线程的生命周期Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。上下文切换多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。线程死锁认识线程死锁多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：123456789101112131415161718192021222324252627282930313233343536public class DeadLockDemo &#123; private static Object resource1 = new Object();//资源 1 private static Object resource2 = new Object();//资源 2 public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (resource1) &#123; System.out.println(Thread.currentThread() + "get resource1"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + "waiting get resource2"); synchronized (resource2) &#123; System.out.println(Thread.currentThread() + "get resource2"); &#125; &#125; &#125;, "线程 1").start(); new Thread(() -&gt; &#123; synchronized (resource2) &#123; System.out.println(Thread.currentThread() + "get resource2"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + "waiting get resource1"); synchronized (resource1) &#123; System.out.println(Thread.currentThread() + "get resource1"); &#125; &#125; &#125;, "线程 2").start(); &#125;&#125;Output1234Thread[线程 1,5,main]get resource1Thread[线程 2,5,main]get resource2Thread[线程 1,5,main]waiting get resource2Thread[线程 2,5,main]waiting get resource1线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。学过操作系统的朋友都知道产生死锁必须具备以下四个条件：互斥条件：该资源任意一个时刻只由一个线程占用。请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。如何避免线程死锁我们只要破坏产生死锁的四个条件中的其中一个就可以了。破坏互斥条件这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。破坏请求与保持条件一次性申请所有的资源。破坏不剥夺条件占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。破坏循环等待条件靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。我们对线程 2 的代码修改成下面这样就不会产生死锁了。1234567891011121314new Thread(() -&gt; &#123; synchronized (resource1) &#123; System.out.println(Thread.currentThread() + "get resource1"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + "waiting get resource2"); synchronized (resource2) &#123; System.out.println(Thread.currentThread() + "get resource2"); &#125; &#125;&#125;, "线程 2").start();我们分析一下上面的代码为什么避免了死锁的发生?线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。sleep() 方法和 wait() 方法两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。两者都可以暂停线程的执行。Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。synchronized 关键字synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。使用方式synchronized关键字最主要的三种使用方式：修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！双重校验锁实现对象单例（线程安全）手写单例模式并解释双重检验锁方式实现单例模式的原理1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125;uniqueInstance 采用 volatile 关键字修饰是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：为 uniqueInstance 分配内存空间初始化 uniqueInstance将 uniqueInstance 指向分配的内存地址但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。synchronized 关键字的底层原理synchronized 关键字底层原理属于 JVM 层面synchronized 同步语句块的情况1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println("synchronized 代码块"); &#125; &#125;&#125;通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行javap -c -s -v -l SynchronizedDemo.class.从上面我们可以看出：synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。synchronized 修饰方法的的情况12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println("synchronized 方法"); &#125;&#125;synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。JDK1.6 之后的synchronized 关键字底层优化JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。①偏向锁引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步.但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。② 轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！③ 自旋锁和自适应自旋轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过--XX:+UseSpinning参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。④ 锁消除锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。⑤ 锁粗化原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。synchronized和ReentrantLock 的区别两者都是可重入锁“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。ReentrantLock 比 synchronized 增加了一些高级功能相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。公平锁就是先等待的线程先获得锁。synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。乐观锁与悲观锁概念悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。乐观锁常见的两种实现方式乐观锁一般会使用版本号机制或CAS算法实现。1. 版本号机制一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。2. CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数需要读写的内存值 V进行比较的值 A拟写入的新值 B当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。关于自旋锁，大家可以看一下这篇文章，非常不错：《 面试必备之深入理解自旋锁》乐观锁的缺点ABA 问题是乐观锁一个常见的问题1 ABA 问题如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。JDK 1.5 以后的 AtomicStampedReference类就提供了此种能力，其中的 compareAndSet()方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。2 循环时间长开销大自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。3 只能保证一个共享变量的原子操作CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。CAS与synchronized的使用情景简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。volatile关键字volatile关键字内存模型在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。synchronized 关键字和 volatile 关键字的区别synchronized关键字和volatile关键字比较volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。ThreadLocalThreadLocal简介通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。再举个简单的例子：比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。ThreadLocal示例相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。1234567891011121314151617181920212223242526272829303132import java.text.SimpleDateFormat;import java.util.Random;public class ThreadLocalExample implements Runnable&#123; // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本 private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat("yyyyMMdd HHmm")); public static void main(String[] args) throws InterruptedException &#123; ThreadLocalExample obj = new ThreadLocalExample(); for(int i=0; i&lt;10; i++)&#123; Thread t = new Thread(obj, ""+i); Thread.sleep(new Random().nextInt(1000)); t.start(); &#125; &#125; @Override public void run() &#123; System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern()); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //formatter pattern is changed here by thread, but it won't reflect to other threads formatter.set(new SimpleDateFormat()); System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern()); &#125;&#125;Output:1234567891011121314151617181920Thread Name= 0 default Formatter = yyyyMMdd HHmmThread Name= 0 formatter = yy-M-d ah:mmThread Name= 1 default Formatter = yyyyMMdd HHmmThread Name= 2 default Formatter = yyyyMMdd HHmmThread Name= 1 formatter = yy-M-d ah:mmThread Name= 3 default Formatter = yyyyMMdd HHmmThread Name= 2 formatter = yy-M-d ah:mmThread Name= 4 default Formatter = yyyyMMdd HHmmThread Name= 3 formatter = yy-M-d ah:mmThread Name= 4 formatter = yy-M-d ah:mmThread Name= 5 default Formatter = yyyyMMdd HHmmThread Name= 5 formatter = yy-M-d ah:mmThread Name= 6 default Formatter = yyyyMMdd HHmmThread Name= 6 formatter = yy-M-d ah:mmThread Name= 7 default Formatter = yyyyMMdd HHmmThread Name= 7 formatter = yy-M-d ah:mmThread Name= 8 default Formatter = yyyyMMdd HHmmThread Name= 9 default Formatter = yyyyMMdd HHmmThread Name= 8 formatter = yy-M-d ah:mmThread Name= 9 formatter = yy-M-d ah:mm从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。上面有一段代码用到了创建 ThreadLocal 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法withInitial()，将Supplier功能接口作为参数。1234567private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123; @Override protected SimpleDateFormat initialValue() &#123; return new SimpleDateFormat("yyyyMMdd HHmm"); &#125; &#125;;ThreadLocal原理从 Thread类源代码入手。123456789public class Thread implements Runnable &#123; ......//与此线程有关的ThreadLocal值。由ThreadLocal类维护ThreadLocal.ThreadLocalMap threadLocals = null;//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ......&#125;从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。ThreadLocal类的set()方法1234567891011public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;通过上面这些内容，我们足以通过猜测得出结论：最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对。 比如我们在同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。ThreadLocal 是 map结构是为了让每个线程可以关联多个 ThreadLocal变量。这也就解释了 ThreadLocal 声明的变量为什么在每一个线程都有自己的专属本地变量。ThreadLocalMap是ThreadLocal的静态内部类。ThreadLocal 内存泄露问题ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125;弱引用介绍：如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。线程池为什么要用线程池？线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。实现Runnable接口和Callable接口的区别如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。备注： 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule）)执行execute()方法和submit()方法的区别execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；submit() 方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。如何创建线程池《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险(Executors 是对ThreadPoolExecutor的包装).Executors 返回线程池对象的弊端如下：FixedThreadPool 和 SingleThreadExecutor: 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。CachedThreadPool 和 ScheduledThreadPool: 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。方式一：通过构造方法实现参数说明:corePoolSize 指定了线程池里的线程数量maximumPoolSize 指定了线程池里的最大线程数量keepAliveTime 当线程池线程数量大于corePoolSize时候，多出来的空闲线程，多长时间会被销毁。unit 时间单位workQueue 任务队列，用于存放提交但是尚未被执行的任务。threadFactory 线程工厂，用于创建线程，一般可以用默认的handler 拒绝策略，当任务过多时候，如何拒绝任务。主要是workQueue和handler的差异比较大workQueue指被提交但未执行的任务队列，它是一个BlockingQueue接口的对象，仅用于存放Runnable对象。方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。对应Executors工具类中的方法如图所示：Atomic 原子类介绍一下Atomic 原子类Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，所谓原子类说简单点就是具有原子/原子操作特征的类。并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示。JUC 包中的4类原子类基本类型使用原子的方式更新基本类型AtomicInteger：整形原子类AtomicLong：长整型原子类AtomicBoolean：布尔型原子类数组类型使用原子的方式更新数组里的某个元素AtomicIntegerArray：整形数组原子类AtomicLongArray：长整形数组原子类AtomicReferenceArray：引用类型数组原子类引用类型AtomicReference：引用类型原子类AtomicStampedReference：原子更新引用类型里的字段原子类AtomicMarkableReference ：原子更新带有标记位的引用类型对象的属性修改类型AtomicIntegerFieldUpdater：原子更新整形字段的更新器AtomicLongFieldUpdater：原子更新长整形字段的更新器AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。AQSAQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。AQS 原理分析AQS 原理这部分参考了部分文章，在此节末尾放了链接。在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。AQS 原理概览AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。看个AQS(AbstractQueuedSynchronizer)原理图：AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。1private volatile int state;//共享变量，使用volatile修饰保证线程可见性状态信息通过protected类型的getState，setState，compareAndSetState进行操作123456789101112//返回同步状态的当前值protected final int getState() &#123; return state;&#125; // 设置同步状态的值protected final void setState(int newState) &#123; state = newState;&#125;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;AQS 对资源的共享方式AQS定义两种资源共享方式Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：公平锁：按照线程在队列中的排队顺序，先到者先拿到锁非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。AQS底层使用了模板方法模式同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：12345isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。AQS 组件总结Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。推荐两篇 AQS 原理和相关源码分析的文章：http://www.cnblogs.com/waterystone/p/4920797.htmlhttps://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库-MySQL]]></title>
    <url>%2Fp%2F3310093647%2F</url>
    <content type="text"><![CDATA[MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。但是，它现在被Oracle收购了…储存引擎查看MySQL提供的所有存储引擎1mysql&gt; show engines;从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。查看MySQL当前默认的存储引擎1mysql&gt; show variables like &apos;%storage_engine%&apos;;查看表的存储引擎1show table status like &quot;table_name&quot; ;MyISAM和InnoDB区别MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。两者的对比：是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。每次锁定的是一行数据的锁机制就是行级别锁定(row-level)。行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。是否支持外键： MyISAM不支持，而InnoDB支持。是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：MySQL-InnoDB-MVCC多版本并发控制MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。……《MySQL高性能》上面有一句话这样写到:不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。字符集及校对规则字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》详细内容可以参考： MySQL字符集及校对规则的理解索引MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》更多关于索引的内容可以查看文档首页MySQL目录下关于索引的详细总结。为什么索引能提高查找速度MySQL的基本存储结构是页(记录都存在页里边)：各个数据页可以组成一个双向链表每个数据页中的记录又可以组成一个单向链表每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。所以说，如果我们写select * from user where indexname = ‘xxx’这样没有进行任何优化的sql语句，默认会这样做：定位到记录所在的页：需要遍历双向链表，找到所在的页从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：要找到id为8的记录简要步骤：很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 “目录” 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。最左前缀原则MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引(复合索引)。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：123select * from user where name=xx and city=xx ; ／／可以命中索引select * from user where name=xx ; // 可以命中索引select * from user where city=xx ; // 无法命中索引这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。注意避免冗余索引冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。MySQL 5.7 版本后，可以通过查询 sys 库的 schema_redundant_indexes 表来查看冗余索引查询缓存的使用执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用my.cnf加入以下配置，重启MySQL开启查询缓存12query_cache_type=1query_cache_size=600000MySQL执行以下命令也可以开启查询缓存12set global query_cache_type=1;set global query_cache_size=600000;如上，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：1select sql_no_cache count(*) from usr;事务事务是逻辑上的一组操作，要么都执行，要么都不执行。事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。事物的四大特性(ACID)原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。并发事务带来哪些问题?在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。不可重复读和幻读区别：不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。事务隔离级别有哪些?MySQL的默认隔离级别是?SQL 标准定义了四个隔离级别：READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。隔离级别脏读不可重复读幻影读READ-UNCOMMITTED√√√READ-COMMITTED×√√REPEATABLE-READ××√SERIALIZABLE×××MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看123456mysql&gt; SELECT @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。锁机制与InnoDB锁算法MyISAM和InnoDB存储引擎使用的锁：MyISAM采用表级锁(table-level locking)。InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁表级锁和行级锁对比：表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。详细内容可以参考： MySQL锁机制简单了解一下：https://blog.csdn.net/qq_34337272/article/details/80611486InnoDB存储引擎的锁的算法有三种：Record lock：单个行记录上的锁Gap lock：间隙锁，锁定一个范围，不包括记录本身Next-key lock：record+gap 锁定一个范围，包含记录本身相关知识点：innodb对于行的查询使用next-key lockNext-locking keying为了解决Phantom Problem幻读问题当查询的索引含有唯一属性时，将next-key lock降级为record keyGap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1大表优化当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：限定数据的范围务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；读/写分离经典的数据库拆分方案，主库负责写，从库负责读；垂直分区根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。 垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；水平分区保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。下面补充一下数据库分片的两种常见方案：客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。详细内容可以参考： MySQL大表优化方案: https://segmentfault.com/a/1190000006158186池化设计思想池话设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。——这篇文章对池化设计思想介绍的还不错，直接复制过来，避免重复造轮子了。数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。连接池还减少了用户必须等待建立与数据库的连接的时间。分库分表之后因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。生成全局 id 有下面这几种方式：UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。Twitter的snowflake算法 ：Github 地址：https://github.com/twitter-archive/snowflake。美团的Leaf分布式ID生成系统 ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。……SQL语句如何执行MySQL基本架构概览下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。•连接器： 身份认证和权限相关(登录 MySQL 的时候)。•查询缓存: 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。•分析器: 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。•优化器： 按照 MySQL 认为最优的方案去执行。•执行器: 执行语句，然后从存储引擎返回数据。简单来说 MySQL 主要分为 Server 层和存储引擎层：•Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。•存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。语句分析我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：1select * from tb_student A where A.age=&apos;18&apos; and A.name=&apos; 张三 &apos;;结合上面的说明，我们分析下这个语句的执行流程：先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：12a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。 b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：1update tb_student A set A.age=&apos;19&apos; where A.name=&apos; 张三 &apos;;我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：•先查询到张三这一条数据，如果有缓存，也是会用到缓存。•然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。•执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。•更新完成。这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？•先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。•先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：•判断 redo log 是否完整，如果判断是完整的，就立即提交。•如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。这样就解决了数据一致性的问题。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决使用html2canvas过程中的一些问题]]></title>
    <url>%2Fp%2F3871219887%2F</url>
    <content type="text"><![CDATA[以下基于v1.0.0-rc5版本（此版本已经解决了网络上一些常见的问题）为了做一个类似分享海报的demo，方便起见（不会canvas）使用html2canvas将html转为canvas再分享为图片。但是在实际使用中发现了h2c的一些问题，记录在下。demo说明demo基于angular，通过填入数据，再将数据显示在对应位置，在需要时通过点击下载卡片或者其他形式将图片下载到本地。项目地址：GitHub/JikeCard演示链接：Jellow Card 项目被我暂停运行了更多说明见项目README图片效果如下：以下将说明遇到的问题。box-shadow样式导出后缺失在v1.0.0-rc2后h2c加入了导出box-shadow的功能，但是当你同时对一个元素设置了border-radius和box-shadow后，导出会出现异常（及样式丢失）例如：1234567.avatar &#123; display: flex; width: 14%; border-radius: 50%; border: solid 4px white; box-shadow: 0 0.2px 0.5px gainsboro;&#125;其中的box-shadow: 0 0.2px 0.5px gainsboro;在导出结果中丢失。在html2canvas项目的pull1848下，你可以找到由wangkaiwen提出的解决办法。该方案对源码（node_modules/html2canvas/dist/html2canvas.js)做出如下修改（将对应源码做替换）：在line 6500 附近：1234567891011CanvasRenderer.prototype.mask = function (paths) &#123; var x=this.options.x,y=this.options.y; this.ctx.beginPath(); this.ctx.moveTo(x, y); this.ctx.lineTo(this.canvas.width+x, y); this.ctx.lineTo(this.canvas.width+x, this.canvas.height+y); this.ctx.lineTo(x, this.canvas.height+y); this.ctx.lineTo(x, y); this.formatPath(paths.slice(0).reverse()); this.ctx.closePath();&#125;;在line 6800附近：1_this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset*window.devicePixelRatio;图片跨域问题以下示例来自 html2canvas示例网页HTML:123&lt;div id="capture" style="padding: 10px; background: #f5da55"&gt; &lt;h4 style="color: #000; "&gt;Hello world!&lt;/h4&gt;&lt;/div&gt;JavaScript:123html2canvas(document.querySelector("#capture")).then(canvas =&gt; &#123; document.body.appendChild(canvas)&#125;);在js中使useCROS=true即可，如：12345html2canvas(document.querySelector("#capture"),&#123; useCROS: true&#125;).then(canvas =&gt; &#123; document.body.appendChild(canvas)&#125;);导出图片清晰度不高在v1.0.01-rc5版本中，不需要通过设置宽度、高度、scale来提高清晰度，使用上面的代码已经可以得到足够清晰的图片。导出图片高度异常此异常有两种情况：div高度过高时生成图片出现白边div在页面上方引起的上半部分丢失div高度过高时生成图片出现白边js加入如下参数：123456html2canvas(document.querySelector("#capture"),&#123; useCROS: true, height: document.getElementById('capture').scrollHeight&#125;).then(canvas =&gt; &#123; document.body.appendChild(canvas)&#125;);div在页面上方引起的上半部分丢失曲线救国，在保存图片前将页面回复到最顶部，即：12345678document.documentElement.scrollTop = 0;document.body.scrollTop = 0;html2canvas(document.querySelector("#capture"),&#123; useCROS: true, height: document.getElementById('capture').scrollHeight&#125;).then(canvas =&gt; &#123; document.body.appendChild(canvas)&#125;);可能存在更优解。导出svg（二维码）错误使用qrcode.js（实际安装的依赖为angularx-qrcode(1.7.0-beta5)）生成二维码，因为图片格式清晰度不高，所以采用svg形式。但是svg导出会出现问题（具体说明问题视你的svg图案，总之就是会出现异常）。异常由svg内未经设置的width引起（应该是，所以下面的解决方案不一定适合非二维码的svg），因此通过设置元素宽度来消除异常：123456789/** * 设置元素宽度(消除异常) */function setSvgElementsWidth() &#123; const svgElements = document.body.querySelectorAll('svg'); svgElements.forEach(item =&gt; &#123; item.setAttribute('width', item.getBoundingClientRect().width.toString()); &#125;);&#125;在生成二维码前调用此方法即可消除异常。在此值得一提的是，angularx-qrcode(1.7.0-b5)插件[usesvg]=&quot;true&quot;时直接用html2canvas导出会引发错误，错误原因由旧版本不兼容es2015引起。插件2.x版本虽修复此问题，但因2.x版本去除了svg选项,导出二维码清晰度不高，故将 tsconfig.json的target 改为 es5。另一点是，svg生成二维码后，二维码的点之间有间隙（像素视觉差异），可以在GitHub/JikeCard中的qrcode 组件找到对应的css和utils/QRCode.ts找到css异常的解决方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-失败型秋招总结]]></title>
    <url>%2Fp%2F985515144%2F</url>
    <content type="text"><![CDATA[写在前面最近考研成绩也都出了，点开这篇文章的估计都是准备找工作了。有同学跟我说求面试经验，趁者还没把前段时间的秋招经历忘光，同时也为了做出一些反思，写下了这篇总结。其实这类总结在网上不胜罗列，而且从高到低都有，大家大可自己去搜索。看个十几篇基本就有数了。我的秋招历程我一开始就觉得自己不是考研的料，大三下半学期就早早开始在准备秋招。那时候还是在找实习，然而我对自己的实力迷之自信，导致我在面试环节基本处于懵逼的状态。那时候杭州有两家小公司给了我实习面试的机会，我就屁颠屁颠的跑过去面试。我面的是Java后端，没想到问了一大堆mysql问题（对于只会最简单的语句的我来说基本是懵逼的）；后来果然凉了。临近大三暑假，该考研的准备考研；该实习的已经找到实习。我忽然觉得自己啥事都没干成，面试里有个“讲讲自己有哪些项目”的环节，我除了课设也基本没啥好讲的了。这时候，有个老师找人做项目，我就抱着得有个项目的心态过去了。结果那个项目缺前端，我就只能从零开始去写前端，用的还是基本没啥企业用的angular框架。我的暑假在一边做项目，一边看面经，一边投一些大厂的前提批的情况下过去了。三成投了甚至都没消息（我都填了内推码了啊），六成笔试挂了，一成面试挂了。我也只能安慰自己这才是提前批，好好准备就能都会了。大四上开学，秋招基本算是正式开始了。项目上放宽了些，但还有些课。这段时间的碰壁才让我愈发绝望。大厂投出去石沉海底，后来都不敢投了；小厂也投了十几家，有给机会的，有不给的，但最多也就到了二面；后来开始去听学校里的宣讲会，希望能捞个保底，至少可以缓解心理上的压力，结果还是颗粒无收。互联网秋招基本结束，各类银行国企开始秋招，那时候一个月去了五趟杭州，只为了一个机会，谁让我自己前期考虑不周。最后倒是有两家公司（都是运营商）接连有消息，最后也都收到了offer。大体看来，我的秋招并不算成功，没去成大厂，也没去能成长的地方，反而去了运营商混吃等死，实在属于鄙视链之底层。我的经历也不是值得宣扬的，但写下来还是值得我回顾和反思的。我的失败之因不给面试机会有如下原因：只能说明我们学校实在太差（当然本质是我太差）。简历太差，乏善可陈。笔试挂了有如下原因：基础知识（选择）范围太大，我复习的内容太少。因为大很多时间都用来赶项目了，准备的时间并不是很多，还有一部分时间被我用来挥霍了（还是自己的问题）。现在想想参加这个项目应该是弊大于利的。算法只会简单问题。刷了一些leetcode的简单题，这个难度上基本都能有思路然后做出解；但是我每次用例考虑不充分，写代码的时候要调很久，浪费很多时间。另一方面，难题和中等难度题基本解不出来。面试挂了有如下原因：面试经验太少。其实我面试的机会并不多，这就导致了我唯一几次面试的时候语言组织上有些问题（要是我自己听到这样的回答也会觉得这人不大行）；也容易说错话。项目经历太少/太简单。面试总会从自我介绍开始，自我介绍里也总会有项目经历；如果从项目这里就聊不开，后面没啥聊的了。基础知识还是太不准备充分。容易紧张。你要找什么工作做计算机的，总要选个方向去做，譬如Java（后端），JS（前端），测试，运营等。在一个很大很多的范围里找一个你有基础且喜欢的方向；我就是投的Java后端。不同方向找工作的机会其实是不一样的，就比如前端比后端好找。有了方向才能在投简历和准备面经的时候提高效率，否则互联网那么大，又岂是一个学生能样样精通的。然后你要确定自己的工作城市。是打算去北上广深杭这类互联网大市，还是南京苏州这类还算有经济实力的城市，或者处于某种考量想去其他城市。可以灵活，但重要有一个范围，总不可能真的随遇而安。我当时就是希望能留在杭沪宁，最后反而回了老家。再然后是薪资范围，这个需要结合个人能力、个人期望、城市和岗位等等因素来看，但底线要有，也是筛选工作的一个标准。最后是你想要去什么样的公司工作。互联网公司（大致分一下是大厂、小厂、创业公司和外包公司）；银行和一些有计算机业务的国企；软硬结合的公司（也有知名的和不知名的）；外企；一些其他零碎的。这里面地位最高的是阿里腾讯之流，其下是逐级而生的鄙视链，这里不一一道来了。当然是我是希望去互联网大厂的，可是有心无力，最后落得个运营商。你要做些什么准备简历——敲门砖简历是你找工作的第一步（当然有些会让你按它们的表单填，内容也是要准备的），简历不好，实在难有后面之机会。关于简历，提一下几点要求：清爽。我们不是什么文案设计，简历不需要花里胡哨，更何况文案设计的简历也是清晰简洁的，让人一看就觉得舒服的。只写重点。必要的信息：联系方式，邮箱，专业，性别等；实习经历（如果有）；项目经历（如果有）；比赛和获奖经历（如果有）；专业技能。如果都没有，那么编；总得写点什么上去。保持一页。删掉没用的东西。我的简历上其实没什么好写的，但是前期还是被我憋出了两页。有大佬同学在看了我的简历后说这里那里面试官都不会看的，都删掉吧；遂删之。当然除非你真的有很多优秀的地方可以写。专业知识准备不管是什么公司，什么形式的面试，总归是要考你的专业知识，只是或简单或难的区别。而且这东西和你平时写的还不太一样，更理论，更像考试。主要有以下两方面，都是只能硬准备的：基础知识。GitHub 上或者其他地方总能找到你所选方向的面经资源，先挑重点的；再把其余的看完。比如Java的https://github.com/Snailclimb/JavaGuide算法。刷算法题（推荐 leetcode ），总结归纳方法。项目如果你有项目，编的好一点、难一点，不要太过，把值得吹的地方的技术点原理看透；如果你没项目，包装一下课设。自我介绍必然要进行的准备，只要有面试官，最开始肯定是让你做个自我介绍。这是要事前准备的，尤其是第一次。我不知道别人怎么自我介绍的，反正我是先说一堆基本信息，然后说一下专业技能，然后就扯到项目经历上。整个过程大概两三分钟。笔试如果你的简历准备的好，你就能收到笔试邀请；如果你专业知识笔试基本不成问题。这里说说我笔试（线上笔试）中遇到的一些问题：大部分笔试都不让你移出答题区的，后台会进行判断，这时候可以把手机放一边查；大部分笔试会要求开摄像头，但是你可以装作写草稿的样子查，会有风险；算法题是大头，如果你算法好，甚至不用看基础；如果算法没思路，可以直接跳下一题；注意时间，不要纠结。面试面试一般分一面（主要面基础和项目）、二面（再面一遍基础和项目）和终面（hr面）；当然每个人怎么面还是有所不同的。面试还是会让你自我介绍，然后根据你的项目展开问一些问题，然后再问一些基础知识；有些会问一些比较复杂点的知识。如果你感觉这次面试因为你有几个问题没答好而结束，那你确实凉了；但是绝不要因为一个问题没答好而紧张，面试一旦紧张后面的问题会也不会了。自我介绍和答题的时候都要扬长避短，会的多说点；不会的少说或者不提及。另一方面，不要不懂装懂，千万不要！不会的问题就说不会，要不然肯定凉。至于到了hr面基本上稳了，不会有技术上的问题，但是会有对你个人的考察。有了offer后如果你手上有了offer，先别急着签，能拖则拖；不能拖再从有的offer里比较（如果有的比）。反正就是不到最后一刻不签。网上还有一些秋招签了三方被坑的经历，这里就不列举了。写在后面去找工作吧！]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2Fp%2F2595394334%2F</url>
    <content type="text"><![CDATA[OSI与TCP/IP各层的结构与功能学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。1.1 应用层应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。域名系统域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司 的域名是www.cisco.com 等。HTTP协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）运输层运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。运输层主要使用以下两种协议:传输控制协议 TCP（Transmission Control Protocol）—提供面向连接的，可靠的数据传输服务。用户数据协议 UDP（User Datagram Protocol）—提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。TCP 与 UDP 的对比见问题三。网络层在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。数据链路层数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。物理层在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。TCP 三次握手和四次挥手(面试常客)为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。TCP 三次握手漫画图解如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。简单示意图：客户端–发送带有 SYN 标志的数据包–一次握手–服务端服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端为什么要三次握手三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。断开一个 TCP 连接则需要“四次挥手”：客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号服务器-关闭与客户端的连接，发送一个FIN给客户端客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1TCP,UDP 协议的区别UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。TCP 协议如何保证可靠传输应用数据被分割成 TCP 认为最适合发送的数据块。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。TCP 的接收端会丢弃重复的数据。流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）拥塞控制： 当网络拥塞时，减少数据的发送。ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。HTTP长连接,短连接在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：1Connection:keep-alive在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。HTTP是不保存状态的协议,如何保存用户状态?HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。Cookie的作用是什么?和Session有什么区别？Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。HTTP 1.0和HTTP 1.1HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。URI和URLURI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。HTTP 和 HTTPS 的区别端口 ：HTTP的URL由http://起始且默认使用端口80，而HTTPS的URL由https://起始且默认使用端口443。安全性和资源消耗：HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageRank算法实现好友推荐(算法原理)]]></title>
    <url>%2Fp%2F325336282%2F</url>
    <content type="text"><![CDATA[对于社交系统与电商网站，推荐系统占有很重要的位置，当数据量越来越大的时候，用户无法确定该选择什么商品，因此在电商系统中需要按照兴趣或者相似度给用户推荐相应的商品。相应的，在一个大型社交网络平台中，对于一些用户，我们希望推荐一些知名度较高，活跃度较高或者感兴趣的用户，比如一些明星，歌手，演员等等。在社交网络中，PageRank算法有着广泛的应用，因此，本篇文章主要介绍其原理。对于大部分社交系统来说，如果只是简单的获取好友的信息远远不够，我们可以通过获取好友的好友的信息来扩展用户的朋友圈，使得信息量更加丰富，本项目中使用PageRank算法来完成二级邻居，然后按照Rank排序，选择Top5用户实现用户的好友的好友的推荐。背景PageRank算法设计之初就是应用于搜索引擎,从技术上看,搜索引擎需要解决以下三个问题:建立资料库建立一种数据结构,这种数据结构能通过keyword找到链接(文档)对检索到的结果进行排序建立资料库本质就是一个爬虫问题,通过爬虫获取整个互联网的数据索引关键在于快速找到.它的实现方式有: 倒排索引，签名文件，后缀树等。我们最熟悉的是倒排索引。(并不熟悉,以后有机会再看)排序排序是Google的搜索引擎能够兴起的一个决定性因素。对网页排序有很多种方式，我们来看三种：不评价词频位置加权PageRank算法不评价就是原封不懂地把索引到的链接直接返回给用户，缺点就不说了，想找自己感兴趣的内容估计要费不少功夫。词频位置加权这种方式是一种只从关键词出现的次数和位置进行排序的方法。该方法以一个关键词与网页的相关度大小作为排序标准，而关键词在网页的相关度大小作为排序标准，而关键词在网页中的相关度则由它在网页中出现的频次和位置两方面加权计算得出。缺点也很明显，容易出现刷分的情况，整篇文章中大量地刷关键词就能提高排名。PageRank算法真正找到计算网页自身质量的完美的数学模型是Google的创始人拉里佩奇和谢尔盖布林。 下一节讲一下原理。PageRank算法原理我们模拟一个悠闲的上网者，上网者首先随机选择一个网页打开，然后在这个网页上呆了几分钟后，跳转到该网页所指向的链接，这样无所事事、漫无目的地在网页上跳来跳去，PageRank就是估计这个悠闲的上网者分布在各个网页上的概率，这个概率就代表这个网页的重要性.PageRank主要基于两个重要的假设：如果一个网页被更多的网页链接到,说明这个网页更重要，也就是PageRank值会高如果一个PageRank值高的网页链接到一个其他的网页，那么被链接到的网页的PageRank值会相应地因此而提高如果一篇文章被越来越多的人引用，那么这篇文章可能就是一篇经典之作，如果这篇文章引用了其他的论文，那么一定程度上这篇被引用的文章也是一篇很好的文章。应用到社交网络中，如果一个好友被更多的人关注，那么说明该好友有很高的知名度和活跃度，那么，我们可以将该好友推荐给用户。基于这两个假设,我们可以总结出PageRank算法的核心:某个页面新的Rank值由当前所有页面的Rank值除以对应的出链个数再求和Rank_{i(new)}= \sum_{j}\frac{Rank_j}{OutLink_j}如下图,可以更好的表达PageRank算法的思想:由上图可知,每个页面将自己的一部分rank传递给某个页面，我们可以通过计算传递给某个页面的所有rank值的和来计算出它的rank值，当然，不可能是通过一次计算完成，我们刚开始可以给每个页面赋予一个初始rank值，比如$\frac{1}{N}(N为页面总数)$，通过迭代计算得到该页面的rank值。迭代计算停止的条件为:新的所有页面的Rank值与旧的所有页面的Rank值之间的变化小于一个预先设定的值。(因为正常情况下变化是收敛的)迭代计算的次数大于预先设定的值。抽象模型有向图使用有向图表示:这个例子中只有四个网页，如果当前在A网页，那么悠闲的上网者将会各以1/3的概率跳转到B、C、D，这里的3表示A有3条出链，如果一个网页有k条出链，那么跳转任意一个出链上的概率是1/k，同理D到B、C的概率各为1/2，而B到C的概率为0。转移矩阵我们在做计算的时候会将该图表示成一个二维的矩阵，我们做一个转换，就会变成下图的矩阵形式。M(i,j)表示j节点指向i节点的概率 ，一般来说每列和为1。\begin{equation} M={ \left[ \begin{array}{ccc} 0 & 1/2 & 1 & 0 & [AA,BA,CA,DA]\\ 1/3 & 0 & 0 & 1/2 & [AB,BB,CB,DB]\\ 1/3 & 0 & 0 & 1/2 & [AC,BC,CC,DC]\\ 1/3 & 1/2 & 0 & 0 & [AD,BD,CD,DD] \end{array} \right ]} \end{equation}生成的转移矩阵非常简单,矩阵的每一列代表该顶点所代表的页面除以对应页面的出链数得到的。更新Rank值有了转移矩阵，我们可以来定义行向量V，V的第i个分量记录$Page_i$对应的Rank值，因此一次Rank的更新可以表示为：\begin{equation} V_n = MV_{n-1} \end{equation}在算法的第一轮计算中，我们假设上网者在每一个网页的概率都是相等的，即1/n，于是初试的概率分布就是一个所有值都为1/n的n维列向量$V_0$，用$V_0$去右乘转移矩阵M，就得到了第一步之后上网者的概率分布向量$MV_0$,得到一个nX1的矩阵$V_1$，这个$V_1$一轮迭代计算出来的PageRank值。下面是$V_1$的计算过程：\begin{equation} V_1=MV_0={ \left[ \begin{array}{ccc} 0 & 1/2 & 1 & 0 \\ 1/3 & 0 & 0 & 1/2 \\ 1/3 & 0 & 0 & 1/2 \\ 1/3 & 1/2 & 0 & 0 \end{array} \right ] \begin{bmatrix} 1/4 \\ 1/4 \\ 1/4 \\ 1/4 \\ \end{bmatrix}} = \begin{bmatrix} 9/24 \\ 5/24 \\ 5/24 \\ 5/24 \\ \end{bmatrix} \end{equation}得到了$V_1$后，再用$V_1$去右乘M得到$V_2$，一直下去，即$V_n=MV_{n-1}$,最终V会收敛.不断的迭代，最终得到结果.算法漏洞但是在迭代计算中，我们需要考虑如下两大阻力： Dead End和Spider Trap：Dead EndDead End就是指一个页面只有入链但是没有出链，这时转移矩阵M的一列为零，导致最后结果为零。这时web不是强连通的，即存在某一类节点不指向别人，如下图的D。这个时候我们的算法就会出问题了，它不满足收敛性了。\begin{equation} M={ \left[ \begin{array}{ccc} 0 & 1/2 & 0 & 0 \\ 1/3 & 0 & 0 & 1/2 \\ 1/3 & 0 & 1 & 1/2 \\ 1/3 & 1/2 & 0 & 0 \end{array} \right ]} \end{equation}为什么不满足收敛性了？我们上面描述的上网者的行为是一个其实马尔科夫过程)的实例，要满足收敛性，需要具备一个条件：图是强连通的，即从任意网页可以到达其他任意网页。一旦出现如上图的D的节点，就不满足收敛性的。百度百科:强连通图)Spider TrapSpider Trap指页面的所有出链都指向自己，这样会使迭代结果中只有自己的页面的Rank值很高。其他页面的Rank值为零。模拟随机跳转要克服上面两个问题，我们需要将迭代计算公式做如下转变。我们可以加入一个随机跳转机制.即假设每个页面有很小概率拥有一个指向其他页面的链接。在事实上,这是模拟上网者除了不断的点击网页上的链接来跳转之外，还有一定概率输入地址的方式、使用浏览器标签等来访问表现出来就是：其他页面本来传递给一个页面的Rank值需要做一个折扣，作为补偿，可能需要一个页面指向该页面并且传递Rank值给该页面，该跳转的概率为β，因此表达式变为：\begin{equation} V_n = (1-β)MV_{n-1} + β\frac{e}{N} \end{equation}其中,N为页面总数;e为一个N维且各个分量都是1的向量;β通过经验得知一般设为0.15.此时的计算结果过程为:\begin{equation} V_1=0.85\times{ \left[ \begin{array}{ccc} 0 & 1/2 & 0 & 0 \\ 1/3 & 0 & 0 & 1/2 \\ 1/3 & 0 & 1 & 1/2 \\ 1/3 & 1/2 & 0 & 0 \end{array} \right ] \begin{bmatrix} 1/4 \\ 1/4 \\ 1/4 \\ 1/4 \end{bmatrix}}+ 0.15\times{ \begin{bmatrix} 1/4 \\ 1/4 \\ 1/4 \\ 1/4 \end{bmatrix}} = \begin{bmatrix} \cdots \\ \cdots \\ \cdots \\ \cdots \\ \end{bmatrix} \end{equation}好友推荐实现思路根据登陆者id获取所有好友的id(set1)根据set1获取好友的好友的id(set2)去除set2中的set1和登陆者id(set3)对set3依照PageRank算法进行迭代取迭代结果的topK(快排)参考文献木东居士：No.4 聊一聊 PageRank 的原理和实现不清不慎：构建分布式微博好友推荐系统【实战开发】]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>推荐算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性]]></title>
    <url>%2Fp%2F964429882%2F</url>
    <content type="text"><![CDATA[接口的默认方法(Default Methods for Interfaces)Java 8使我们能够通过使用 default 关键字向接口添加非抽象方法实现。 此功能也称为虚拟扩展方法。第一个例子：123456interface Formula&#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125;Formula 接口中除了抽象方法计算接口公式还定义了默认方法 sqrt。 实现该接口的类只需要实现抽象方法 calculate。 默认方法sqrt 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。12345678910111213public class Main &#123; public static void main(String[] args) &#123; // TODO 通过匿名内部类方式访问接口 Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125; &#125;; System.out.println(formula.calculate(100)); // 100.0 System.out.println(formula.sqrt(16)); // 4.0 &#125;&#125;formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。译者注： 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。Lambda表达式(Lambda expressions)首先看看在老版本的Java中是如何排列字符串的：12345678List&lt;String&gt; names = Arrays.asList("peter", "anna", "mike", "xenia");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;);只需要给静态方法Collections.sort 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 sort 方法。在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;);可以看出，代码变得更段且更具有可读性，但是实际上还可以写得更短：1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：1names.sort((a, b) -&gt; b.compareTo(a));List 类本身就有一个 sort 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。函数式接口(Functional Interfaces)Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。像这样的接口，可以被隐式转换为lambda表达式。“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。java.lang.Runnable 与 java.util.concurrent.Callable 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解@FunctionalInterface,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用@FunctionalInterface 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示示例：1234@FunctionalInterfacepublic interface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;1234// TODO 将数字字符串转换为整数类型Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert("123");System.out.println(converted.getClass()); //class java.lang.Integer译者注： 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。方法和构造函数引用(Method and Constructor References)前一节中的代码还可以通过静态方法引用来表示：123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert("123");System.out.println(converted.getClass()); //class java.lang.IntegerJava 8允许您通过::关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：12345class Something &#123; String startsWith(String s) &#123; return String.valueOf(s.charAt(0)); &#125;&#125;1234Something something = new Something();Converter&lt;String, String&gt; converter = something::startsWith;String converted = converter.convert("Java");System.out.println(converted); // "J"接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：1234567891011class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125;接下来我们指定一个用来创建Person对象的对象工厂接口：123interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125;这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create("Peter", "Parker");我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的参数类型来选择合适的构造函数。Lamda 表达式作用域(Lambda Scopes)访问局部变量我们可以直接在 lambda 表达式中访问外部的局部变量：12345final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：12345int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：1234int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);num = 3;//在lambda表达式中试图修改num同样是不允许的。访问字段和静态变量与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。12345678910111213141516class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125;访问默认接口方法还记得第一节中的 formula 示例吗？ Formula 接口定义了一个默认方法sqrt，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。无法从 lambda 表达式中访问默认方法,故以下代码无法编译：1Formula formula = (a) -&gt; sqrt(a * 100);内置函数式接口(Built-in Functional Interfaces)JDK 1.8 API包含许多内置函数式接口。 其中一些接口在老版本的 Java 中是比较常见的比如： Comparator 或Runnable，这些接口都增加了@FunctionalInterface注解以便能用在 lambda 表达式上。但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 Google Guava 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。PredicatesPredicate 接口是只有一个参数的返回布尔类型值的 断言型 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：译者注： Predicate 接口源码如下1234567891011121314151617181920212223242526272829package java.util.function;import java.util.Objects;@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; // 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断. boolean test(T t); //and方法与关系型运算符"&amp;&amp;"相似，两边都成立才返回true default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; // 与关系运算符"!"相似，对判断进行取反 default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; //or方法与关系型运算符"||"相似，两边只要有一个成立就返回true default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; // 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal). static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;示例：12345678910Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test("foo"); // truepredicate.negate().test("foo"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();FunctionsFunction 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：译者注： Function 接口源码如下123456789101112131415161718192021222324package java.util.function; import java.util.Objects; @FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; //将Function对象应用到输入的参数上，然后返回计算结果。 R apply(T t); //将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。 default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; // default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125;123Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply("123"); // "123"SuppliersSupplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new PersonConsumersConsumer 接口表示要对单个输入参数执行的操作。12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println("Hello, " + p.firstName);greeter.accept(new Person("Luke", "Skywalker"));ComparatorsComparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：1234567Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person("John", "Doe");Person p2 = new Person("Alice", "Wonderland");comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0OptionalsOptionals不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optionals的工作原理。Optional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。译者注：示例中每个方法的作用已经添加。12345678910//of（）：为非null的值创建一个OptionalOptional&lt;String&gt; optional = Optional.of("bam");// isPresent（）： 如果值存在返回true，否则返回falseoptional.isPresent(); // true//get()：如果Optional有值则将其返回，否则抛出NoSuchElementExceptionoptional.get(); // "bam"//orElse（）：如果有值则将其返回，否则返回指定的其它值optional.orElse("fallback"); // "bam"//ifPresent（）：如果Optional实例有值则为其调用consumer，否则不做处理optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // "b"推荐阅读：Java8如何正确使用OptionalStreams(流)java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如java.util.Collection 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。首先看看Stream是怎么用，首先创建实例代码的用到的数据List：123456789List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add("ddd2");stringList.add("aaa2");stringList.add("bbb1");stringList.add("aaa1");stringList.add("bbb3");stringList.add("ccc");stringList.add("bbb2");stringList.add("ddd1");Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：Filter(过滤)过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。12345// 测试 Filter(过滤)stringList .stream() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println);//aaa2 aaa1forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。Sorted(排序)排序是一个 中间操作，返回的是排序好后的 Stream。如果你不指定一个自定义的 Comparator 则会使用默认排序。123456// 测试 Sort (排序)stringList .stream() .sorted() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println);// aaa1 aaa2需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：1System.out.println(stringList);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1Map(映射)中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。123456// 测试 Map 操作stringList .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"Match(匹配)Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 最终操作 ，并返回一个 boolean 类型的值。1234567891011121314151617181920// 测试 Match (匹配)操作boolean anyStartsWithA = stringList .stream() .anyMatch((s) -&gt; s.startsWith("a"));System.out.println(anyStartsWithA); // trueboolean allStartsWithA = stringList .stream() .allMatch((s) -&gt; s.startsWith("a"));System.out.println(allStartsWithA); // falseboolean noneStartsWithZ = stringList .stream() .noneMatch((s) -&gt; s.startsWith("z"));System.out.println(noneStartsWithZ); // trueCount(计数)计数是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。1234567//测试 Count (计数)操作 long startsWithB = stringList .stream() .filter((s) -&gt; s.startsWith("b")) .count(); System.out.println(startsWithB); // 3Reduce(规约)这是一个 最终操作 ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：12345678//测试 Reduce (规约)操作Optional&lt;String&gt; reduced = stringList .stream() .sorted() .reduce((s1, s2) -&gt; s1 + "#" + s2);reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2译者注： 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于Integer sum = integers.reduce(0, (a, b) -&gt; a+b);也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。123456789101112// 字符串连接，concat = "ABCD"String concat = Stream.of("A", "B", "C", "D").reduce("", String::concat); // 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = "ace"concat = Stream.of("a", "B", "c", "D", "e", "F"). filter(x -&gt; x.compareTo("Z") &gt; 0). reduce("", String::concat);上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： IBM：Java 8 中的 Streams API 详解Parallel Streams(并行流)前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。下面的例子展示了是如何通过并行Stream来提升性能：首先我们创建一个没有重复元素的大表：123456int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125;我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。Sequential Sort(串行排序)123456789//串行排序long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format("sequential sort took: %d ms", millis));121000000sequential sort took: 709 ms//串行排序所用的时间Parallel Sort(并行排序)12345678910//并行排序long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format("parallel sort took: %d ms", millis));121000000parallel sort took: 475 ms//串行排序所用的时间上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 stream() 改为parallelStream()。Maps前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 stream（）方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。此外,Maps 支持各种新的和有用的方法来执行常见任务。1234567Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, "val" + i);&#125;map.forEach((id, val) -&gt; System.out.println(val));//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9putIfAbsent 阻止我们在null检查时写入额外的代码;forEach接受一个 consumer 来对 map 中的每个元素操作。此示例显示如何使用函数在 map 上计算代码：1234567891011map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3); // val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -&gt; "val" + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -&gt; "bam");map.get(3); // val33接下来展示如何在Map里删除一个键值全都匹配的项：1234map.remove(3, "val3");map.get(3); // val33map.remove(3, "val33");map.get(3); // null另外一个有用的方法：1map.getOrDefault(42, "not found"); // not found对Map的元素做合并也变得很容易了：1234map.merge(9, "val9", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9map.merge(9, "concat", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9concatMerge 做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。Date API(日期相关API)Java 8在 java.time 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。译者注(总结)：Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用 Instant 类来表示，Instant 类也可以用来创建旧版本的java.util.Date 对象。在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类ZoneId（在java.time包中）表示一个区域标识符。 它有一个名为getAvailableZoneIds的静态方法，它返回所有区域标识符。jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。ClockClock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用 Instant 类来表示，Instant 类也可以用来创建旧版本的java.util.Date 对象。1234567Clock clock = Clock.systemDefaultZone();long millis = clock.millis();System.out.println(millis);//1552379579043Instant instant = clock.instant();System.out.println(instant);Date legacyDate = Date.from(instant); //2019-03-12T08:46:42.588ZSystem.out.println(legacyDate);//Tue Mar 12 16:32:59 CST 2019Timezones(时区)在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类ZoneId（在java.time包中）表示一个区域标识符。 它有一个名为getAvailableZoneIds的静态方法，它返回所有区域标识符。1234567//输出所有区域标识符System.out.println(ZoneId.getAvailableZoneIds());ZoneId zone1 = ZoneId.of("Europe/Berlin");ZoneId zone2 = ZoneId.of("Brazil/East");System.out.println(zone1.getRules());// ZoneRules[currentStandardOffset=+01:00]System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=-03:00]LocalTime(本地时间)LocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：123456789LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.123456789LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late); // 23:59:59DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse("13:37", germanFormatter);System.out.println(leetTime); // 13:37LocalDate(本地日期)LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。123456789LocalDate today = LocalDate.now();//获取现在的日期System.out.println("今天的日期: "+today);//2019-03-12LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);System.out.println("明天的日期: "+tomorrow);//2019-03-13LocalDate yesterday = tomorrow.minusDays(2);System.out.println("昨天的日期: "+yesterday);//2019-03-11LocalDate independenceDay = LocalDate.of(2019, Month.MARCH, 12);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println("今天是周几:"+dayOfWeek);//TUESDAY从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用 DateTimeFormatter 解析字符串的例子：12345678910111213String str1 = "2014==04==12 01时06分09秒"; // 根据需要解析的日期、时间字符串定义解析所用的格式器 DateTimeFormatter fomatter1 = DateTimeFormatter .ofPattern("yyyy==MM==dd HH时mm分ss秒"); LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1); System.out.println(dt1); // 输出 2014-04-12T01:06:09 String str2 = "2014$$$四月$$$13 20小时"; DateTimeFormatter fomatter2 = DateTimeFormatter .ofPattern("yyy$$$MMM$$$dd HH小时"); LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2); System.out.println(dt2); // 输出 2014-04-13T20:00再来看一个使用 DateTimeFormatter 格式化日期的示例12345LocalDateTime rightNow=LocalDateTime.now();String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);System.out.println(date);//2019-03-12T16:26:48.29DateTimeFormatter formatter=DateTimeFormatter.ofPattern("YYYY-MM-dd HH:mm:ss");System.out.println(formatter.format(rightNow));//2019-03-12 16:26:48LocalDateTime(本地日期时间)LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。12345678910LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。123456Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：123456DateTimeFormatter formatter = DateTimeFormatter .ofPattern("MMM dd, yyyy - HH:mm");LocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 关于时间日期格式的详细信息在这里。Annotations(注解)在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。 首先定义一个包装类Hints注解用来放置一组具体的Hint注解：1234567@interface Hints &#123; Hint[] value();&#125;@Repeatable(Hints.class)@interface Hint &#123; String value();&#125;Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。例 1: 使用包装类当容器来存多个注解（老方法）12@Hints(&#123;@Hint("hint1"), @Hint("hint2")&#125;)class Person &#123;&#125;例 2：使用多重注解（新方法）123@Hint("hint1")@Hint("hint2")class Person &#123;&#125;第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：1234567Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint); // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); // 2即便我们没有在 Person类上定义 @Hints注解，我们还是可以通过 getAnnotation(Hints.class)来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。 另外Java 8的注解还增加到两种新的target上了：12@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>面试</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机初探]]></title>
    <url>%2Fp%2F3741091999%2F</url>
    <content type="text"><![CDATA[对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。Java内存模型Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。JDK1.8之前JDK1.8线程私有的：程序计数器虚拟机栈本地方法栈线程共享的：堆方法区直接内存 (非运行时数据区的一部分)程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。从上面的介绍中我们知道程序计数器主要有两个作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。Java 虚拟机栈与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。扩展：那么方法/函数如何调用？Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。Java 方法有两种返回方式：return 语句。抛出异常。不管哪种返回方式都会导致栈帧被弹出。本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。方法区方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。常用参数JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小12-XX:PermSize=N //方法区 (永久代) 初始大小-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：12-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。Q: 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。当然这只是其中一个原因，还有很多底层的原因，这里就不提了。运行时常量池运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。HotSpot 虚拟机对象探秘下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。对象的创建类加载检查虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。分配内存在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。内存分配的两种方式：（补充内容，需要掌握）选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的内存分配并发问题（补充内容，需要掌握）在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配初始化零值内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。设置对象头初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。执行 init 方法在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。对象的内存布局在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。对象的访问定位建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有①使用句柄和②直接指针两种：句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。类加载过程Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？系统加载 Class 类型的文件主要三步:加载-&gt;连接-&gt;初始化。连接过程又可分为三步:验证-&gt;准备-&gt;解析。加载类加载过程的第一步，主要完成下面3件事情：通过全类名获取定义此类的二进制字节流将字节流所代表的静态存储结构转换为方法区的运行时数据结构在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。验证准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。基本数据类型的零值：解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。符号引用是一个字符串，它给出了被引用的内容的名字并且可能会包含一些其他关于这个被引用项的信息——这些信息必须足以唯一的识别一个类、字段、方法。这样，对于其他类的符号引用必须给出类的全名。对于其他类的字段，必须给出类名、字段名以及字段描述符。对于其他类的方法的引用必须给出类名、方法名以及方法的描述符。这样我们就能根据符号引用锁定唯一的类，方法或字段了。java语言是解释性的语言，然后由于总总原因（我也不知道对不对的原因）在某些时刻有些东西的直接地址还并不存在，是无法使用直接引用。这时候就可以用到符号引用了。原文链接直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。初始化初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 &lt;clinit&gt;()方法的过程。()执行在类的初始化阶段方法 的执行时期: 对象的初始化阶段对于&lt;clinit&gt;() 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 &lt;clinit&gt;() 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。特殊类型补充String 类和常量池String 对象的两种创建方式：12345String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；String str2 = new String("abcd");//堆中创建一个新的对象String str3 = new String("abcd");//堆中创建一个新的对象System.out.println(str1==str2);//falseSystem.out.println(str2==str3);//false这两种不同的创建方法是有差别的。第一种方式是在常量池中拿对象；第二种方式是直接在堆内存空间创建一个新的对象。记住一点：只要使用 new 方法，便需要创建新的对象。再给大家一个图应该更容易理解，图片来源：https://www.journaldev.com/797/what-is-java-string-pool：String 类型的常量池比较特殊。它的主要使用方法有两种：直接使用双引号声明出来的 String 对象会直接存储在常量池中。如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。123456String s1 = new String("计算机");String s2 = s1.intern();String s3 = "计算机";System.out.println(s2);//计算机System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象字符串拼接:123456789String str1 = "str";String str2 = "ing"; String str3 = "str" + "ing";//常量池中的对象String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = "string";//常量池中的对象System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。8 种基本类型的包装类和常量池Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；这 5 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。为啥把缓存设置为[-128，127]区间？（参见issue/461）性能和资源之间的权衡。同时,这个缓存设置区间是可以被更改的.两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。123456789Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 falseInteger 缓存源代码：12345678/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;应用场景：Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。Integer i1 = new Integer(40);这种情况下会创建新的对象。123Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2);//输出 falseInteger 比较更丰富的一个例子:12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0); System.out.println("i1=i2 " + (i1 == i2));System.out.println("i1=i2+i3 " + (i1 == i2 + i3));System.out.println("i1=i4 " + (i1 == i4));System.out.println("i4=i5 " + (i4 == i5));System.out.println("i4=i5+i6 " + (i4 == i5 + i6)); System.out.println("40=i5+i6 " + (40 == i5 + i6));结果：123456i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true解释：语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。JVM 垃圾回收JVM 内存分配与回收Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代;再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。堆空间的基本结构：上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到年老代中。对象优先在 eden 区分配目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。在测试之前我们先来看看 Minor GC 和 Full GC 有什么不同呢？新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。测试：12345678public class GCTest &#123; public static void main(String[] args) &#123; byte[] allocation1, allocation2; allocation1 = new byte[30900*1024]; //allocation2 = new byte[900*1024]; &#125;&#125;通过以下方式运行： 添加的参数：-XX:+PrintGCDetails 运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？1allocation2 = new byte[900*1024];简单解释一下为什么会出现这种情况： 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：1234567891011public class GCTest &#123; public static void main(String[] args) &#123; byte[] allocation1, allocation2,allocation3,allocation4,allocation5; allocation1 = new byte[32000*1024]; allocation2 = new byte[1000*1024]; allocation3 = new byte[1000*1024]; allocation4 = new byte[1000*1024]; allocation5 = new byte[1000*1024]; &#125;&#125;大对象直接进入老年代大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。为什么要这样呢？为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。动态对象年龄判定为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。判定对象死亡引用计数器给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。1234567891011public class ReferenceCountingGc &#123; Object instance = null; public static void main(String[] args) &#123; ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; &#125;&#125;可达性分析算法这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。再谈引用无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）强引用（StrongReference）以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。软引用（SoftReference）如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。弱引用（WeakReference）如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。虚引用（PhantomReference）“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。不可达的对象并非“非死不可”即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程:可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。判断一个常量是废弃常量运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。加载该类的 ClassLoader 已经被回收。该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。垃圾收集算法标记-清除算法该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：效率问题空间问题（标记清除后会产生大量不连续的碎片）复制算法为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。标记-整理算法根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。分代收集算法当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。延伸面试问题： HotSpot 为什么要分为新生代和老年代？根据上面的对分代收集算法的介绍回答。垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。Serial 收集器Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。新生代采用复制算法，老年代采用标记-整理算法。虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。ParNew 收集器ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。新生代采用复制算法，老年代采用标记-整理算法。它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。并行和并发概念补充：并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。Parallel Scavenge 收集器Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 那么它有什么特别之处呢？12345-XX:+UseParallelGC 使用 Parallel 收集器+ 老年代串行-XX:+UseParallelOldGC使用 Parallel 收集器+ 老年代并行Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。新生代采用复制算法，老年代采用标记-整理算法。Serial Old 收集器Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。Parallel Old 收集器Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。CMS 收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：对 CPU 资源敏感；无法处理浮动垃圾；它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。G1 收集器G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。空间整合：与 CMS 的“标记—清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。G1 收集器的运作大致分为以下几个步骤：初始标记并发标记最终标记筛选回收G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>转载</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[首先了解什么是Spring]]></title>
    <url>%2Fp%2F1507653627%2F</url>
    <content type="text"><![CDATA[Spring IoC&amp;AOPAOPAOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：AOP思想的实现一般都是基于 代理模式 ，在Java中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。推荐阅读：静态代理、JDK动态代理、CGLIB动态代理讲解 ：我们知道AOP思想的实现一般都是基于 代理模式 ，所以在看下面的文章之前建议先了解一下静态代理以及JDK动态代理、CGLIB动态代理的实现方式。Spring AOP 入门 ：带你入门的一篇文章。这篇文章主要介绍了AOP中的基本概念：5种类型的通知（Before，After，After-returning，After-throwing，Around）；Spring中对AOP的支持：AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，Spring AOP 基于AspectJ注解如何实现AOP ： AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器），可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态植入。至于AspectJ的静态植入，不是本文重点，所以只提一提。探秘Spring AOP（慕课网视频，很不错）:慕课网视频，讲解的很不错，详细且深入spring源码剖析（六）AOP实现原理剖析 :通过源码分析Spring AOP的原理IoCIoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。控制反转,将对象的控制交给第三方IOC容器依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。Spring IOC的初始化过程： [Spring框架]Spring IOC的原理及详解。Spring IOC核心源码学习 :比较简短，推荐阅读。Spring IOC 容器源码分析 :强烈推荐，内容详尽，而且便于阅读。什么是 Spring 框架?Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：https://spring.io/。我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。Spring 官网列出的 Spring 的 6 个特征:核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。Web支持 : Spring MVC和Spring WebFlux Web框架。集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。语言 ：Kotlin，Groovy，动态语言。列举一些重要的Spring模块？下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。Spring Aspects ： 该模块为与AspectJ的集成提供支持。Spring AOP ：提供了面向切面的编程实现。Spring JDBC : Java数据库连接。Spring JMS ：Java消息服务。Spring ORM : 用于支持Hibernate等ORM工具。Object-Relationl Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了 。Spring Web : 为创建Web应用程序提供支持。Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。@RestController vs @ControllerController 返回一个页面单独使用 @Controller 不加 @ResponseBody的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。@RestController 返回JSON 或 XML 形式数据但@RestController只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。@Controller +@ResponseBody 返回JSON 或 XML 形式数据如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用@Controller 并结合@ResponseBody注解，也就是说@Controller +@ResponseBody= @RestController（Spring 4 之后新加的注解）。@ResponseBody 注解的作用是将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。Reference:https://dzone.com/articles/spring-framework-restcontroller-vs-controller（图片来源）https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html?m=1Spring beanSpring 中的 bean 的作用域singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。prototype : 每次请求都会创建一个新的 bean 实例。request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话Spring 中的单例 bean 的线程安全问题大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。常见的有两种解决办法：在Bean对象中尽量避免定义可变的成员变量（不太现实）。在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。@Component 和 @Bean 的区别作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。@Bean注解使用示例：1234567@Configurationpublic class AppConfig &#123; @Bean public TransferService transferService() &#123; return new TransferServiceImpl(); &#125;&#125;上面的代码相当于下面的 xml 配置123&lt;beans&gt; &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;&lt;/beans&gt;下面这个例子是通过 @Component 无法实现的。1234567891011@Beanpublic OneService getService(status) &#123; switch (status) &#123; case 1: return new serviceImpl1(); case 2: return new serviceImpl2(); case 3: return new serviceImpl3(); &#125;&#125;将一个类声明为Spring的 bean 的注解有哪些?我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。Spring 中的 bean 生命周期这部分网上有很多文章都讲到了，下面的内容整理自：https://yemengying.com/2016/07/14/spring-bean-life-cycle/ ，除了这篇文章，再推荐一篇很不错的文章 ：https://www.cnblogs.com/zrtqsk/p/3735273.html 。Bean 容器找到配置文件中 Spring Bean 的定义。Bean 容器利用 Java Reflection API 创建一个Bean的实例。如果涉及到一些属性值 利用 set()方法设置一些属性值。如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r对象的实例。与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。图示：与之比较类似的中文版本:Spring MVC谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。Model1 时代 : 很多学 Java 后端比较晚的朋友可能并没有接触过 Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；Model2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。Spring MVC 的简单原理图如下：SpringMVC 工作原理原理如下图所示： 上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 DispatcherServlet 的作用是接收请求，响应结果。流程说明（重要）：客户端（浏览器）发送请求，直接请求到 DispatcherServlet。DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。ViewResolver 会根据逻辑View 查找实际View。DispaterServlet 把返回的 Model 传给 View（视图渲染）。把 View 返回给请求者（浏览器）Spring 框架中用到了哪些设计模式？关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章《面试官:“谈谈Spring中都用到了那些设计模式?”。》 。工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。代理设计模式 : Spring AOP 功能的实现。单例设计模式 : Spring 中的 Bean 默认都是单例的。模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。……Spring 事务Spring 管理事务的方式编程式事务，在代码中硬编码。(不推荐使用)声明式事务，在配置文件中配置（推荐使用）声明式事务又分为两种：基于XML的声明式事务基于注解的声明式事务Spring 事务中的隔离级别种类TransactionDefinition 接口中定义了五个表示隔离级别的常量：TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。8.3 Spring 事务中哪几种事务传播行为?支持当前事务的情况：TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）不支持当前事务的情况：TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。其他情况：TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。@Transactional(rollbackFor = Exception.class)注解我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。当@Transactional注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。JPA使用JPA在数据库中非持久化一个字段假如我们有有下面一个类：1234567891011121314151617Entity(name="USER")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = "ID") private Long id; @Column(name="USER_NAME") private String userName; @Column(name="PASSWORD") private String password; private String secrect; &#125;如果我们想让secrect 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：12345static String transient1; // not persistent because of staticfinal String transient2 = “Satish”; // not persistent because of finaltransient String transient3; // not persistent because of transient@TransientString transient4; // not persistent because of @Transient一般使用后面两种方式比较多，我个人使用注解的方式比较多。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>面试</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合类详细介绍]]></title>
    <url>%2Fp%2F1326311149%2F</url>
    <content type="text"><![CDATA[Java集合类介绍(简单介绍的版本)Java数组的基本操作ArrayList和LinkedList各自实现和区别Java Map类之HashMap实现原理及源码分析Collections 工具类和 Arrays 工具类常见方法CollectionsCollections 工具类常用方法:排序查找,替换操作同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)排序操作123456void reverse(List list)//反转void shuffle(List list)//随机排序void sort(List list)//按自然排序的升序排序void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑void swap(List list, int i , int j)//交换两个索引位置的元素void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。查找,替换1234567int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。int frequency(Collection c, Object o)//统计元素出现次数int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).boolean replaceAll(List list, Object oldVal, Object newVal)// 用新元素替换旧元素Arrays类的常见操作排序 : sort()查找 : binarySearch()比较: equals()填充 : fill()转列表: asList()转字符串 : toString()复制: copyOf()排序: sort()12345678910111213141516171819202122232425262728293031323334353637383940// *************排序 sort**************** int a[] = &#123; 1, 3, 2, 7, 6, 5, 4, 9 &#125;; // sort(int[] a)方法按照数字顺序排列指定的数组。 Arrays.sort(a); System.out.println("Arrays.sort(a):"); for (int i : a) &#123; System.out.print(i); &#125; // 换行 System.out.println(); // sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围 int b[] = &#123; 1, 3, 2, 7, 6, 5, 4, 9 &#125;; Arrays.sort(b, 2, 6); System.out.println("Arrays.sort(b, 2, 6):"); for (int i : b) &#123; System.out.print(i); &#125; // 换行 System.out.println(); int c[] = &#123; 1, 3, 2, 7, 6, 5, 4, 9 &#125;; // parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序 Arrays.parallelSort(c); System.out.println("Arrays.parallelSort(c)："); for (int i : c) &#123; System.out.print(i); &#125; // 换行 System.out.println(); // parallelSort给字符数组排序，sort也可以 char d[] = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;; Arrays.parallelSort(d); System.out.println("Arrays.parallelSort(d)："); for (char d2 : d) &#123; System.out.print(d2); &#125; // 换行 System.out.println();在做算法面试题的时候，我们还可能会经常遇到对字符串排序的情况,Arrays.sort() 对每个字符串的特定位置进行比较，然后按照升序排序。123String[] strs = &#123; "abcdehg", "abcdefg", "abcdeag" &#125;;Arrays.sort(strs);System.out.println(Arrays.toString(strs));//[abcdeag, abcdefg, abcdehg]查找 : binarySearch()只能对已经排序的数组进行查找12345678// *************查找 binarySearch()****************char[] e = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;// 排序后再进行二分查找，否则找不到Arrays.sort(e);System.out.println("Arrays.sort(e)" + Arrays.toString(e));System.out.println("Arrays.binarySearch(e, 'c')：");int s = Arrays.binarySearch(e, 'c');System.out.println("字符c在数组的位置：" + s);比较: equals()12345678// *************比较 equals****************char[] e = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;char[] f = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;/** 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。*/// 输出trueSystem.out.println("Arrays.equals(e, f):" + Arrays.equals(e, f));填充 : fill()1234567891011121314151617181920// *************填充fill(批量初始化)****************int[] g = &#123; 1, 2, 3, 3, 3, 3, 6, 6, 6 &#125;;// 数组中所有元素重新分配值Arrays.fill(g, 3);System.out.println("Arrays.fill(g, 3)：");// 输出结果：333333333for (int i : g) &#123; System.out.print(i);&#125;// 换行System.out.println();int[] h = &#123; 1, 2, 3, 3, 3, 3, 6, 6, 6, &#125;;// 数组中指定范围元素重新分配值Arrays.fill(h, 0, 2, 9);System.out.println("Arrays.fill(h, 0, 2, 9);：");// 输出结果：993333666for (int i : h) &#123; System.out.print(i);&#125;转列表 asList()123456789// *************转列表 asList()****************/* * 返回由指定数组支持的固定大小的列表。 * （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。 * 返回的列表是可序列化的，并实现RandomAccess 。 * 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下： */List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly");System.out.println(stooges);转字符串 toString()123456// *************转字符串 toString()****************/** 返回指定数组的内容的字符串表示形式。*/char[] k = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;System.out.println(Arrays.toString(k));// [a, f, b, c, e, A, C, B]复制 copyOf()1234567891011121314151617181920// *************复制 copy****************// copyOf 方法实现数组复制,h为数组，6为复制的长度int[] h = &#123; 1, 2, 3, 3, 3, 3, 6, 6, 6, &#125;;int i[] = Arrays.copyOf(h, 6);System.out.println("Arrays.copyOf(h, 6);：");// 输出结果：123333for (int j : i) &#123; System.out.print(j);&#125;// 换行System.out.println();// copyOfRange将指定数组的指定范围复制到新数组中int j[] = Arrays.copyOfRange(h, 6, 11);System.out.println("Arrays.copyOfRange(h, 6, 11)：");// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)for (int j2 : j) &#123; System.out.print(j2);&#125;// 换行System.out.println();List,Set与MapList(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。ArrayList与LinkedList是否保证线程安全ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；底层数据结构Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）插入和删除是否受元素位置的影响ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。LinkedList 采用链表存储，所以对于add(�E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度应为o(n))因为需要新创立一个新的链表，复制前i-1个元素并在第i位加入新的元素，最后附上n-i个元素。是否支持快速随机访问LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。内存空间占用ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。快速随机访问:RandomAccess接口1public interface RandomAccess &#123; &#125;查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。在 binarySearch（）方法中，它要判断传入的list 是否 RamdomAccess 的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法.1234567public static &lt;T&gt;int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key);&#125;ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！下面再总结一下 list 的遍历方式选择：实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach,未实现 RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环补充内容:双向链表和双向循环链表双向链表： 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。双向循环链表： 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。ArrayList这里补充一点比较重要，但是容易被忽视掉的知识点：java 中的 length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!ArrayList与VectorVector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要保证线程安全时建议使用Arraylist。System.arraycopy() 和 Arrays.copyOf()方法阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及add(int index, E element)、toArray() 等方法中都用到了该方法！System.arraycopy() 方法123456789101112131415/** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;我们写一个简单的方法测试以下：1234567891011121314151617public class ArraycopyTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] a = new int[10]; a[0] = 0; a[1] = 1; a[2] = 2; a[3] = 3; System.arraycopy(a, 2, a, 3, 3); // 将a中从2开始的位置(的3个)复制到a数组的3开始的位置 a[2]=99; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; &#125;&#125;结果：10 1 99 2 3 0 0 0 0 0Arrays.copyOf()方法1234567/** 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 */ public Object[] toArray() &#123; //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size); &#125;个人觉得使用 Arrays.copyOf()方法主要是为了给原有数组扩容，测试代码如下：1234567891011public class ArrayscopyOfTest &#123; public static void main(String[] args) &#123; int[] a = new int[3]; a[0] = 0; a[1] = 1; a[2] = 2; int[] b = Arrays.copyOf(a, 10); System.out.println("b.length"+b.length); &#125;&#125;结果：110两者联系和区别联系：看两者源代码可以发现 copyOf() 内部实际调用了 System.arraycopy() 方法区别：arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf() 是系统自动在内部新建一个数组，并返回该数组。HashMap与Hashtable线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;HashMap 和 HashSet区别如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。HashMapHashSet实现了Map接口实现Set接口存储键值对仅存储对象调用 put()向map中添加元素调用 add()方法向Set中添加元素HashMap使用键（Key）计算HashcodeHashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，HashSet如何检查重复当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）hashCode()与equals()的相关规定：如果两个对象相等，则hashcode一定也是相同的两个对象相等,对两个equals方法返回true两个对象有相同的hashcode值，它们也不一定是相等的综上，equals方法被覆盖过，则hashCode方法也必须被覆盖hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。==与equals的区别==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同==是指对内存地址进行比较 equals()是对字符串的内容进行比较==指引用是否相同 equals()指的是值是否相同HashMapJDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。JDK 1.8 HashMap 的 hash 方法源码:JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;对比一下 JDK1.7的 HashMap 的 hash 方法源码.12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。Q: HashMap 的长度为什么是2的幂次方?为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。Q: 这个算法应该如何设计呢？我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。两者的对比图：HashTable:JDK1.7的ConcurrentHashMap：JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：ConcurrentHashMap线程安全的具体实现方式/底层具体实现JDK1.7（上面有示意图）首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。1static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; &#125;一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。JDK1.8 （上面有示意图）ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。comparable 和 Comparator的区别comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().Comparator定制排序123456789101112131415161718192021222324252627282930ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();arrayList.add(-1);arrayList.add(3);arrayList.add(3);arrayList.add(-5);arrayList.add(7);arrayList.add(4);arrayList.add(-9);arrayList.add(-7);System.out.println("原始数组:");System.out.println(arrayList);// void reverse(List list)：反转Collections.reverse(arrayList);System.out.println("Collections.reverse(arrayList):");System.out.println(arrayList);// void sort(List list),按自然排序的升序排序Collections.sort(arrayList);System.out.println("Collections.sort(arrayList):");System.out.println(arrayList);// 定制排序的用法Collections.sort(arrayList, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125;&#125;);System.out.println("定制排序后：");System.out.println(arrayList);Output:12345678原始数组:[-1, 3, 3, -5, 7, 4, -9, -7]Collections.reverse(arrayList):[-7, -9, 4, 7, -5, 3, 3, -1]Collections.sort(arrayList):[-9, -7, -5, -1, 3, 3, 4, 7]定制排序后：[7, 4, 3, 3, -1, -5, -7, -9]重写compareTo方法实现按年龄来排序1234567891011121314151617181920212223242526272829303132333435363738394041424344// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /** * TODO重写compareTo方法实现按年龄来排序 */ @Override public int compareTo(Person o) &#123; // TODO Auto-generated method stub if (this.age &gt; o.getAge()) &#123; return 1; &#125; else if (this.age &lt; o.getAge()) &#123; return -1; &#125; return age; &#125;&#125;123456789101112public static void main(String[] args) &#123; TreeMap&lt;Person, String&gt; pdata = new TreeMap&lt;Person, String&gt;(); pdata.put(new Person("张三", 30), "zhangsan"); pdata.put(new Person("李四", 20), "lisi"); pdata.put(new Person("王五", 10), "wangwu"); pdata.put(new Person("小红", 5), "xiaohong"); // 得到key的值的同时得到key所对应的值 Set&lt;Person&gt; keys = pdata.keySet(); for (Person key : keys) &#123; System.out.println(key.getAge() + "-" + key.getName()); &#125;&#125;Output：12345-小红10-王五20-李四30-张三]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>集合</tag>
        <tag>面试</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程与并发(详细总结)]]></title>
    <url>%2Fp%2F1616465807%2F</url>
    <content type="text"><![CDATA[Java多线程-1-线程安全与锁Java多线程-2-可重入锁以及Synchronized的其他基本特性线程与进程进程概念进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。线程概念线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。123456789101112public class MultiThread &#123; public static void main(String[] args) &#123; // 获取 Java 线程管理 MXBean ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息 ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); // 遍历线程信息，仅打印线程 ID 和线程名称信息 for (ThreadInfo threadInfo : threadInfos) &#123; System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName()); &#125; &#125;&#125;上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：12345[5] Attach Listener //添加事件[4] Signal Dispatcher // 分发处理给 JVM 信号的线程[3] Finalizer //调用对象 finalize 方法的线程[2] Reference Handler //清除 reference 线程[1] main //main 线程,程序入口从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。进程和线程的关系从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。总结： 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反下面是该知识点的扩展内容！下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？程序计数器为什么是私有的?程序计数器主要有下面两个作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。虚拟机栈和本地方法栈为什么是私有的?虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。一句话简单了解堆和方法区堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。进程间通信进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息.IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。管道管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。FIFOFIFO，也称为命名管道，它是一种文件类型。FIFO可以在无关的进程之间交换数据，与无名管道不同。FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。消息队列消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。信号量信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。支持信号量组。共享内存共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。并发与并行的区别并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；并行： 单位时间内，多个任务同时执行。多线程先从总体上来说：从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。再深入到计算机底层来探讨：单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。多线程可能带来的问题并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。线程的生命周期Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。上下文切换多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。线程死锁认识线程死锁多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：123456789101112131415161718192021222324252627282930313233343536public class DeadLockDemo &#123; private static Object resource1 = new Object();//资源 1 private static Object resource2 = new Object();//资源 2 public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (resource1) &#123; System.out.println(Thread.currentThread() + "get resource1"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + "waiting get resource2"); synchronized (resource2) &#123; System.out.println(Thread.currentThread() + "get resource2"); &#125; &#125; &#125;, "线程 1").start(); new Thread(() -&gt; &#123; synchronized (resource2) &#123; System.out.println(Thread.currentThread() + "get resource2"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + "waiting get resource1"); synchronized (resource1) &#123; System.out.println(Thread.currentThread() + "get resource1"); &#125; &#125; &#125;, "线程 2").start(); &#125;&#125;Output1234Thread[线程 1,5,main]get resource1Thread[线程 2,5,main]get resource2Thread[线程 1,5,main]waiting get resource2Thread[线程 2,5,main]waiting get resource1线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。学过操作系统的朋友都知道产生死锁必须具备以下四个条件：互斥条件：该资源任意一个时刻只由一个线程占用。请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。如何避免线程死锁我们只要破坏产生死锁的四个条件中的其中一个就可以了。破坏互斥条件这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。破坏请求与保持条件一次性申请所有的资源。破坏不剥夺条件占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。破坏循环等待条件靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。我们对线程 2 的代码修改成下面这样就不会产生死锁了。1234567891011121314new Thread(() -&gt; &#123; synchronized (resource1) &#123; System.out.println(Thread.currentThread() + "get resource1"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + "waiting get resource2"); synchronized (resource2) &#123; System.out.println(Thread.currentThread() + "get resource2"); &#125; &#125;&#125;, "线程 2").start();我们分析一下上面的代码为什么避免了死锁的发生?线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。sleep() 方法和 wait() 方法两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。两者都可以暂停线程的执行。Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。synchronized 关键字synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。使用方式synchronized关键字最主要的三种使用方式：修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！双重校验锁实现对象单例（线程安全）手写单例模式并解释双重检验锁方式实现单例模式的原理1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125;uniqueInstance 采用 volatile 关键字修饰是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：为 uniqueInstance 分配内存空间初始化 uniqueInstance将 uniqueInstance 指向分配的内存地址但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。synchronized 关键字的底层原理synchronized 关键字底层原理属于 JVM 层面synchronized 同步语句块的情况1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println("synchronized 代码块"); &#125; &#125;&#125;通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行javap -c -s -v -l SynchronizedDemo.class.从上面我们可以看出：synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。synchronized 修饰方法的的情况12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println("synchronized 方法"); &#125;&#125;synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。JDK1.6 之后的synchronized 关键字底层优化JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。①偏向锁引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步.但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。② 轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！③ 自旋锁和自适应自旋轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过--XX:+UseSpinning参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。④ 锁消除锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。⑤ 锁粗化原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。synchronized和ReentrantLock 的区别两者都是可重入锁“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。ReentrantLock 比 synchronized 增加了一些高级功能相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。公平锁就是先等待的线程先获得锁。synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。乐观锁与悲观锁概念悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。乐观锁常见的两种实现方式乐观锁一般会使用版本号机制或CAS算法实现。1. 版本号机制一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。2. CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数需要读写的内存值 V进行比较的值 A拟写入的新值 B当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。关于自旋锁，大家可以看一下这篇文章，非常不错：《 面试必备之深入理解自旋锁》乐观锁的缺点ABA 问题是乐观锁一个常见的问题1 ABA 问题如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。JDK 1.5 以后的 AtomicStampedReference类就提供了此种能力，其中的 compareAndSet()方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。2 循环时间长开销大自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。3 只能保证一个共享变量的原子操作CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。CAS与synchronized的使用情景简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。volatile关键字volatile关键字内存模型在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。synchronized 关键字和 volatile 关键字的区别synchronized关键字和volatile关键字比较volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。ThreadLocalThreadLocal简介通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。再举个简单的例子：比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。ThreadLocal示例相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。1234567891011121314151617181920212223242526272829303132import java.text.SimpleDateFormat;import java.util.Random;public class ThreadLocalExample implements Runnable&#123; // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本 private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat("yyyyMMdd HHmm")); public static void main(String[] args) throws InterruptedException &#123; ThreadLocalExample obj = new ThreadLocalExample(); for(int i=0; i&lt;10; i++)&#123; Thread t = new Thread(obj, ""+i); Thread.sleep(new Random().nextInt(1000)); t.start(); &#125; &#125; @Override public void run() &#123; System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern()); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //formatter pattern is changed here by thread, but it won't reflect to other threads formatter.set(new SimpleDateFormat()); System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern()); &#125;&#125;Output:1234567891011121314151617181920Thread Name= 0 default Formatter = yyyyMMdd HHmmThread Name= 0 formatter = yy-M-d ah:mmThread Name= 1 default Formatter = yyyyMMdd HHmmThread Name= 2 default Formatter = yyyyMMdd HHmmThread Name= 1 formatter = yy-M-d ah:mmThread Name= 3 default Formatter = yyyyMMdd HHmmThread Name= 2 formatter = yy-M-d ah:mmThread Name= 4 default Formatter = yyyyMMdd HHmmThread Name= 3 formatter = yy-M-d ah:mmThread Name= 4 formatter = yy-M-d ah:mmThread Name= 5 default Formatter = yyyyMMdd HHmmThread Name= 5 formatter = yy-M-d ah:mmThread Name= 6 default Formatter = yyyyMMdd HHmmThread Name= 6 formatter = yy-M-d ah:mmThread Name= 7 default Formatter = yyyyMMdd HHmmThread Name= 7 formatter = yy-M-d ah:mmThread Name= 8 default Formatter = yyyyMMdd HHmmThread Name= 9 default Formatter = yyyyMMdd HHmmThread Name= 8 formatter = yy-M-d ah:mmThread Name= 9 formatter = yy-M-d ah:mm从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。上面有一段代码用到了创建 ThreadLocal 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法withInitial()，将Supplier功能接口作为参数。1234567private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123; @Override protected SimpleDateFormat initialValue() &#123; return new SimpleDateFormat("yyyyMMdd HHmm"); &#125; &#125;;ThreadLocal原理从 Thread类源代码入手。123456789public class Thread implements Runnable &#123; ......//与此线程有关的ThreadLocal值。由ThreadLocal类维护ThreadLocal.ThreadLocalMap threadLocals = null;//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ......&#125;从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。ThreadLocal类的set()方法1234567891011public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;通过上面这些内容，我们足以通过猜测得出结论：最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对。 比如我们在同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。ThreadLocal 是 map结构是为了让每个线程可以关联多个 ThreadLocal变量。这也就解释了 ThreadLocal 声明的变量为什么在每一个线程都有自己的专属本地变量。ThreadLocalMap是ThreadLocal的静态内部类。ThreadLocal 内存泄露问题ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125;弱引用介绍：如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。线程池为什么要用线程池？线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。实现Runnable接口和Callable接口的区别如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。备注： 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule）)执行execute()方法和submit()方法的区别execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；submit() 方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。如何创建线程池《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险(Executors 是对ThreadPoolExecutor的包装).Executors 返回线程池对象的弊端如下：FixedThreadPool 和 SingleThreadExecutor: 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。CachedThreadPool 和 ScheduledThreadPool: 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。方式一：通过构造方法实现参数说明:corePoolSize 指定了线程池里的线程数量maximumPoolSize 指定了线程池里的最大线程数量keepAliveTime 当线程池线程数量大于corePoolSize时候，多出来的空闲线程，多长时间会被销毁。unit 时间单位workQueue 任务队列，用于存放提交但是尚未被执行的任务。threadFactory 线程工厂，用于创建线程，一般可以用默认的handler 拒绝策略，当任务过多时候，如何拒绝任务。主要是workQueue和handler的差异比较大workQueue指被提交但未执行的任务队列，它是一个BlockingQueue接口的对象，仅用于存放Runnable对象。方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。对应Executors工具类中的方法如图所示：Atomic 原子类介绍一下Atomic 原子类Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，所谓原子类说简单点就是具有原子/原子操作特征的类。并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示。JUC 包中的4类原子类基本类型使用原子的方式更新基本类型AtomicInteger：整形原子类AtomicLong：长整型原子类AtomicBoolean：布尔型原子类数组类型使用原子的方式更新数组里的某个元素AtomicIntegerArray：整形数组原子类AtomicLongArray：长整形数组原子类AtomicReferenceArray：引用类型数组原子类引用类型AtomicReference：引用类型原子类AtomicStampedReference：原子更新引用类型里的字段原子类AtomicMarkableReference ：原子更新带有标记位的引用类型对象的属性修改类型AtomicIntegerFieldUpdater：原子更新整形字段的更新器AtomicLongFieldUpdater：原子更新长整形字段的更新器AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。AQSAQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。AQS 原理分析AQS 原理这部分参考了部分文章，在此节末尾放了链接。在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。AQS 原理概览AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。看个AQS(AbstractQueuedSynchronizer)原理图：AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。1private volatile int state;//共享变量，使用volatile修饰保证线程可见性状态信息通过protected类型的getState，setState，compareAndSetState进行操作123456789101112//返回同步状态的当前值protected final int getState() &#123; return state;&#125; // 设置同步状态的值protected final void setState(int newState) &#123; state = newState;&#125;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;AQS 对资源的共享方式AQS定义两种资源共享方式Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：公平锁：按照线程在队列中的排队顺序，先到者先拿到锁非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。AQS底层使用了模板方法模式同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：12345isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。AQS 组件总结Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。推荐两篇 AQS 原理和相关源码分析的文章：http://www.cnblogs.com/waterystone/p/4920797.htmlhttps://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>面试</tag>
        <tag>转载</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非典型Java基础/疑难杂症]]></title>
    <url>%2Fp%2F2993615910%2F</url>
    <content type="text"><![CDATA[正确使用equals方法Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。举个例子：1234567// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常String str = null;if (str.equals("SnailClimb")) &#123; ...&#125; else &#123; ..&#125;运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。1"SnailClimb".equals(str);// false不过更推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。1Objects.equals(null,"SnailClimb");// false我们看一下java.util.Objects#equals的源码就知道原因了。1234public static boolean equals(Object a, Object b) &#123; // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。 return (a == b) || (a != null &amp;&amp; a.equals(b));&#125;注意每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中null == null将返回true。不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常这里有一个有意思的点,Null(null).a()(a为类Null的静态方法,会正常执行BigDecimalBigDecimal 的用处《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：12345float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;System.out.println(a);// 0.100000024System.out.println(b);// 0.099999964System.out.println(a == b);// false具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（精度丢失），我们如何解决这个问题呢？一种很常用的方法是：使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。123456BigDecimal a = new BigDecimal("1.0");BigDecimal b = new BigDecimal("0.9");BigDecimal c = new BigDecimal("0.8");BigDecimal x = a.subtract(b);// 0.1BigDecimal y = b.subtract(c);// 0.1System.out.println(x.equals(y));// trueBigDecimal比较大小a.compareTo(b) : 返回 -1 表示小于，0 表示 等于， 1表示 大于。123BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);System.out.println(a.compareTo(b));// 1BigDecimal 保留几位小数通过 setScale()方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。123BigDecimal m = new BigDecimal(&quot;1.255433&quot;);BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);System.out.println(n);// 1.255BigDecimal 的使用注意事项注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。总结BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念基本数据类型与包装数据类型的使用标准Reference:《阿里巴巴Java开发手册》【强制】所有的 POJO 类属性必须使用包装数据类型。【强制】RPC 方法的返回值和参数必须使用包装数据类型。【推荐】所有的局部变量使用基本数据类型。比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.说明 :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE(NullPoniterExpection) 问题，或者入库检查，都由使用者来保证。正例 : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例 : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。RPC方法Remote Procedure Call(远程过程调用)分布式是促使RPC诞生的领域.在分布式系统中,你将以给服务A单独放出来,然后用别的服务B去调用它.这时候,我们会想到A暴露一个类似Restful接口,然后服务B调用这个Restful接口来间接什调用A中的方法.这已经接近RPC了,但是每次这样都需要发出http请求,需要将它改成使用者感知不到的方式.我们可以使用代理模式,最好结合Spring IoC一起使用，通过Spring注入calculator对象，注入时，如果扫描到对象加了@Reference注解，那么就给它生成一个代理对象，将这个代理对象放进容器中。而这个代理对象的内部，就是通过httpClient来实现RPC远程过程调用的。参考:如何给老婆解释什么是RPC实体类POJO(plain old java object)普通的java对象，有别于特殊的java对象(含继承约束等)和EJB。POJO一般只有一系列的属性和相应的get、set方法PO(persistant object)持久化对象，有别于POJO,必须对应数据库中的实体。一个PO对应数据库的一条记录。持久化对象的生命周期与数据库密切相关，只能存在于connection之中，连接关闭后，PO就消失了。PO相对于POJO有诸多不同，比如PO中会有保存数据库entity状态的属性和方法。但是ORM(object-relation mapping)追求的目标是PO和POJO的一致，所以在程序员的日常开发中，都是将POJO作为PO使用，而将POJO转化为PO的功能交给hibernate等框架来实现。DTO(data transfer object)数据传输对象，以前被称为值对象(VO,value object)，作用仅在于在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO并不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。DAO(data access object)数据访问对象。提供访问数据库的抽象接口，或者持久化机制，而不暴露数据库的内部详细信息。DAO提供从程序调用到持久层的匹配。BO(business object)业务对象。主要是将业务逻辑封装为一个对象，该对象可以包含一个或多个其他对象。如，”Principal”(委托人)，有”Name”,”Age”等属性，同时和”Employee”(雇员)有1对多的关系，这个”Principal”就可以作为一个与业务相关的PO。集合Arrays.asList()使用指南Arrays.asList()在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。1234String[] myArray = &#123; "Apple", "Banana", "Orange" &#125;； List&lt;String&gt; myList = Arrays.asList(myArray);//上面两个语句等价于下面一条语句List&lt;String&gt; myList = Arrays.asList("Apple","Banana", "Orange");JDK 源码对于这个方法的说明：123456/** *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。 */ public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125;注意事项传递的数组必须是对象数组，而不是基本类型。Arrays.asList()是泛型方法，传入的对象必须是对象数组。1234567int[] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size());//1System.out.println(myList.get(0));//数组地址值System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsExceptionint [] array=(int[]) myList.get(0);System.out.println(array[0]);//1当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。我们使用包装类型数组就可以解决这个问题。1Integer[] myArray = &#123; 1, 2, 3 &#125;;使用集合的修改方法:add()、remove()、clear()会抛出异常。1234List myList = Arrays.asList(1, 2, 3);myList.add(4);//运行时报错：UnsupportedOperationExceptionmyList.remove(1);//运行时报错：UnsupportedOperationExceptionmyList.clear();//运行时报错：UnsupportedOperationExceptionArrays.asList()将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：Arrays.asList()方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。12List myList = Arrays.asList(1, 2, 3);System.out.println(myList.getClass());//class java.util.Arrays$ArrayList正确的将数组转换为ArrayList1. 自己动手实现（教育目的）123456789//JDK1.5+static &lt;T&gt; List&lt;T&gt; arrayToList(final T[] array) &#123; final List&lt;T&gt; l = new ArrayList&lt;T&gt;(array.length); for (final T s : array) &#123; l.add(s); &#125; return (l);&#125;12Integer [] myArray = &#123; 1, 2, 3 &#125;;System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList2. 最简便的方法(推荐)1List list = new ArrayList&lt;&gt;(Arrays.asList("a", "b", "c"))3. 使用 Java8 的Stream(推荐)12345Integer [] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());4. 使用 Guava(推荐)对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）12List&lt;String&gt; il = ImmutableList.of("string", "elements"); // from varargsList&lt;String&gt; il = ImmutableList.copyOf(aStringArray); // from arrayCollection.toArray()方法使用的坑&amp;如何反转数组该方法是一个泛型方法：T[] toArray(T[] a); 如果toArray方法中没有传递任何参数的话返回的是Object类型数组。123456String [] s= new String[]&#123; "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"&#125;;List&lt;String&gt; list = Arrays.asList(s);Collections.reverse(list);s=list.toArray(new String[0]);//没有指定类型的话会报错由于JVM优化，new String[0]作为Collection.toArray()方法的参数现在使用更好，new String[0]就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：https://shipilev.net/blog/2016/arrays-wisdom-ancients/不要在 foreach 循环里进行元素的 remove/add 操作如果要进行remove操作，可以调用迭代器的 remove方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove/add方法，迭代器都将抛出一个ConcurrentModificationException,这就是单线程状态下产生的 fail-fast 机制。fail-fast 机制 ：多个线程对 fail-fast 集合进行修改的时侯，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。java.util包下面的所有的集合类都是fail-fast的，而java.util.concurrent包下面的所有的类都是fail-safe的。序列化和反序列化序列化把对象转换为字节序列的过程称为对象的序列化。反序列化把字节序列恢复为对象的过程称为对象的反序列化。对象的序列化主要有两种用途：把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；在网络上传送对象的字节序列。使用场景在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些session先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。Java对象的序列化和反序列化JDK类库中的序列化APIjava.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。对象序列化包括如下步骤：创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；通过对象输出流的writeObject()方法写对象。对象反序列化的步骤如下：创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；通过对象输入流的readObject()方法读取对象。serialVersionUID的作用serialVersionUID: 字面意思上是序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量1private static final long serialVersionUID序列化版本ID的真实用途：当实体中增加属性后，文件流中的class和classpath中的class，也就是修改过后的class，不兼容了，处于安全机制考虑，程序抛出了错误，并且拒绝载入。那么如果我们真的有需求要在序列化后添加一个字段或者方法呢？应该怎么办？那就是自己去指定serialVersionUID。在例子中，如果没有指定Person类的serialVersionUID的，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。可以说serialVersionUID是序列化和反序列化之间彼此认识的唯一信物。Q: Java序列化中如果有些字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用transient关键字修饰。transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。n++与++n的实现原理略参考资料Java 基础知识疑难点/易错]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java最基础的基础知识]]></title>
    <url>%2Fp%2F325336281%2F</url>
    <content type="text"><![CDATA[以下内容主要来源:GitHub项目JavaGuide,同时对一些地方进行了些许补充,对原来的内容进行了一些组织和增删.因未曾一一记录引用和查询来源,特此说明并表示感谢.面向对象和面向过程面向过程: 没有面向过程易维护,易复用,易扩展面向对象: 易维护,易复用,易扩展, 可以利用封装继承多态的特性,设计出低耦合的系统,是系统更灵活,更加易于维护Java语言的特点平台无关Java虚拟机实现平台无关面向对象封装继承多态支持多线程C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持网络编程Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便编译与解释并存JVM详见《Java虚拟机》Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。Q: 什么是什么是字节码?采用字节码的好处是什么?在Java中,JVM可以理解的代码就叫字节码(.class),它不面向任何特定的处理器,子面向虚拟机.Java通过字节码的形式,在一定程度上解决了传统痛解释型语言执行效率低的问题,同时有保留了解释型语言可移植的特点.所以Java程序运行比较高效,并且无需重新编译即可在多种不同的操作系统中运行.Java程序从源码到运行一般有以下三步:格外注意.class-&gt;机器码这一步.在这一步JVM类加载器首先加载字节码文件,然后通过解释器逐行解释,这种方式的执行速度会相对比较慢.而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。Java应用程序&amp;小程序Q: 什么是 Java 程序的主类?应用程序和小程序的主类有何不同?一个程序可以有多个类,但是只能有一个主类.在Java程序中,这个主类指包含main()方法的类;而在Java小程序中,这个主类是一个继承自系统类JApplet或Applet的子类(真正的mian()方法在其中).应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类.Q: Java 应用程序与小程序之间有哪些差别?应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main() 方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。字符型常量和字符串常量形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)占内存大小: 字符常量只占2个字节; 字符串常量占若干个字节(至少一个字符结束标志)(注意： char在Java中占两个字节)重载和重写重载(overload)重写(override)发生在父子类中,方法名、参数列表比讯相同,返回值范围≤父类,抛出异常范围≤父类,修饰符范围≥父类;若父类方法访问修饰符为 private 则子类就不能重写该方法封装,继承,多态封装封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。关于继承如下 3 点请记住：子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。子类可以拥有自己属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。String, StringBuffer, StringBuilder可变性因为String类使用final关键字修饰字符数组来保存字符串private final char[] value, 所以String对象是不可变的.而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。123456789abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125;&#125;线程安全性String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的.性能每次对String类型进行改变的时候,都会生成一个新的String对象,然后将指针指向性的对象.StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。对于三者使用的总结：操作少量的数据: 适用String单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer构造方法构造方法的特性名字与类名相同。没有返回值，但不能用void声明构造函数。生成类的对象时自动执行，无需调用。super()Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。Q: 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?帮助值子类做初始化工作.接口和抽象类所有方法在接口中不能有实现(Java8开始接口中可以有默认实现);抽象类可以有非抽象的方法;接口中除了static、final不能有其他修饰符修饰的变量,抽象类则不一定;一个类可以实现多个接口,但是只能实现一个抽象类;接口本身可以通过extends继承多个接口;接口的方法默认是public,抽象方法可以有public、protected和default这些修饰符(为了抽象方法可以被重写,不能用private关键字);从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。成员变量和局部变量从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。==与equals()==它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型\==比较的是值，引用数据类型\==比较的是内存地址)equals()它的作用也是判断两个对象是否相等,但它一般有两种情况“类没有覆盖equals()方法则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。类覆盖了 equals() 方法我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)举例:1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String("ab"); // a 为一个引用 String b = new String("ab"); // b为另一个引用,对象的内容一样 String aa = "ab"; // 放在常量池中 String bb = "ab"; // 从常量池中查找 if (aa == bb) // true System.out.println("aa==bb"); if (a == b) // false，非同一对象 System.out.println("a==b"); if (a.equals(b)) // true System.out.println("aEQb"); if (42 == 42.0) &#123; // true System.out.println("true"); &#125; &#125;&#125;说明:String 中的 equals() 方法是被重写过的，因为 object 的 equals() 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。hashCode和equalshashCode()简介hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）为什么有hashCode()我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。hashCode()与equals()的相关规定如果两个对象相等,则hashcode一定也是相同的两个对象相等,对两个对象分别调用equals()方法都返回true两个对象有相同的hashcode值,他们也不一定是相等的equals()方法被覆盖过,则hashCode()方法也必须被覆盖hashCode()的默认行为是对堆上的对象产生独特值.如果没有重写hashCode(),则该class的两个对象无论如何都不会相等(即使则两个对象指向相同的数据)Java值传递为什么Java只有值传递?首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。线程,程序和进程线程线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。线程的基本状态Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：由上图可以看出:线程创建之后将处于NEW(新建)状态,调用start()方法后开始运行,线程这时候处于READY(可运行)状态.可运行状态的线程获得了cpu时间片之后就处于RUNNING((运行)状态.操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。当线程执行waiting()方法之后,线程进入WAITING(等待)状态.进入等待状态的线程需要依靠其他线程的通知才能返回到运行状态,而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。final, static, super关键字final关键字final关键字主要用在三个地方：变量、方法、类。对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升.现在的Java版本已经不需要使用final方法进行这些优化了,类中所有的private方法都隐式地指定为final。static关键字static 关键字主要有以下四种使用场景：修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。super关键字super关键字用于从子类访问父类的变量和方法。 例如：1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println("number = " + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125;在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。使用 this 和 super 要注意的问题：在构造器中使用 super() 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。this、super不能用在static方法中。简单解释一下：被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。Java异常处理Java异常类层次结构图在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。Error（错误）是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。Exception（异常）是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。Throwable类常用方法public string getMessage():返回异常发生时的详细信息public string toString():返回异常发生时的简要描述public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同public void printStackTrace():在控制台上打印Throwable对象封装的异常信息异常处理总结try 块： 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。catch 块： 用于处理try捕获到的异常。finally 块： 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下,finally块不会被执行:finally语句块第一行发送了异常在前面的代码执行了System.exit(int)已退出程序exit()是带参函数;若该语句在异常语句之后,finally回执行程序所在的线程死亡关闭CPU注意:当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：123456789public static int f(int value) &#123; try &#123; return value * value; &#125; finally &#123; if (value == 2) &#123; return 0; &#125; &#125;&#125;如果调用 f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。Java中的IO流IO流分类按照流的流向分，可以分为输入流和输出流；按照操作单元划分，可以划分为字节流和字符流；按照流的角色划分为节点流和处理流。Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。Q: 既然有了字节流,为什么还要有字符流?问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。BIO,NIO,AIOBIO (Blocking I/O)同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。NIO (New I/O)NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发AIO (Asynchronous I/O)AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。如果你意犹未尽,可以看下一篇非典型Java基础/疑难杂症]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>面试</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创造一个死锁的情形]]></title>
    <url>%2Fp%2F2914875511%2F</url>
    <content type="text"><![CDATA[死锁概念多个线程互相持有对方所需要的资源，导致这些线程处于等待状态。产生的必要条件互斥：一个资源只允许一个线程访问（厕所一个坑只能一个人上厕所）占有且等待：一个线程占有资源，同时还有其他线程未得到满足，正在等待其他线程释放该资源（厕所坑里进了一个人，外面还有一个人等着里面的人厕所用完）不可抢占：其他线程已经占有了某项资源，不能因为你需要就抢过来（别人已经进坑里上厕所了，不能因为你也要上，直接把那人揪出来，不合适吧，哈哈）循环等待：发生死锁时，所等待的线程必定会形成一个环路，造成永久阻塞可以通俗的概括为：当前线程拥有其他线程需要的资源当前线程等待其他线程已拥有的资源都不放弃自己拥有的资源死锁实现死锁造成的影响很少会显现出来，如果一个类可能发生死锁，那么一般是在高并发，很糟糕的时候发生死锁。手写一个简单的死锁，下面这段代码加了延时，只要运行就会产生死锁：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package DeadLock;/*写一个两个线程死锁的程序 * coded by Jerome */class MyDeadLock implements Runnable&#123; boolean flag; static Object o1 = new Object(); static Object o2 = new Object(); public MyDeadLock(boolean flag)&#123; this.flag = flag; &#125; public void run()&#123; if(this.flag)&#123; synchronized (o1) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; System.out.println("我没发生死锁"); &#125; &#125; &#125; else&#123; synchronized (o2) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; System.out.println("我也是"); &#125; &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Thread t1 = new Thread(new MyDeadLock(true)); Thread t2 = new Thread(new MyDeadLock(false)); t1.start(); t2.start(); &#125; &#125;运行这段代码，控制台什么都没显示，说明发生了死锁。sleep()是不放弃拥有的资源的，若要修改死锁状态，可以使用wait()（释放资源，进入线程池等待）。死锁预防互斥条件是必须的，不能被改变，还应该加以保证破坏“占有且等待”：所有线程在开始运行之前，必须一次性的申请在整个运行过程中所需要的全部资源，允许线程只获取运行初期需要的资源，在运行过程中逐步的释放掉使用完毕的资源；破坏“不可抢占条件”：当一个已经持有了一些资源的线程在提出新的资源请求没有得到满足时，它必须释放掉已经保持的所有资源；破坏“循环等待”：定义资源类型的线性顺序来预防。方法：固定加锁顺序开放调用使用定时锁死锁检测参考链接pengboboer：手写死锁plugcy：手写一个死锁程序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程实现交替运行]]></title>
    <url>%2Fp%2F36920602%2F</url>
    <content type="text"><![CDATA[这是我去年阿里笔试的时候遇到的题，要求三个线程交替打印 ‘a,l,i’（当时根本没来得及做），这次翻出来看看原来好简单（现在看那时候的五题都挺简单的，还是那时候准备的太少了，活该被刷）（现在也准备的少…）关于线程的站内链接：Java多线程-1-线程安全与锁，Java多线程-2-可重入锁以及Synchronized的其他基本特性两个线程交替打印奇偶数先看两个线程交替运行1234567891011121314151617181920212223242526272829303132333435363738394041public class Work2 &#123; static final Object object = new Object(); public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (object) &#123; for (int i = 1; i &lt; 10; i += 2) &#123; System.out.println(Thread.currentThread().getName() + " " + i); object.notify(); try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (object) &#123; for (int i = 2; i &lt; 10; i += 2) &#123; System.out.println(Thread.currentThread().getName() + " " + i); object.notify(); try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125;运行结果：123456789t1 1t2 2t1 3t2 4t1 5t2 6t1 7t2 8t1 9该实现的原理也非常简单，定义一个对象，因为一个对象有且只有一个锁，所以让两个线程循环让此对象解锁-&gt;加锁，从而达到线程交替运行的目的。创建三个线程交替循环打印’A,B,C’法一：synchronized主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就是前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印字母，之后首先调用self.notifyAll()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B,A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ABC &#123; static class ThreadPrinter implements Runnable &#123; static int i = 0; private String name;// 打印的内容 private Object prev;// 上一个线程持有的锁 private Object self;// 自己持有的锁 // 构造方法 public ThreadPrinter(String name, Object prev, Object self) &#123; super(); this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; // 首先获取上一个线程的锁 // 然后再获取自己的锁 // 持有两把锁才能打印A|B|C // 打印完了之后首先释放自己的所标记 self.notifyAll(); // 然后释放上一个线程的所标记 prev.wait(); // 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒 while (i &lt; 30) &#123; // 先获取prev锁 synchronized (prev) &#123; // 再获取self锁 synchronized (self) &#123; System.out.print(name); i++; self.notifyAll();// 先释放 self，唤醒其他线程竞争self锁 &#125; /** * 注意的是notify()调用后，并不是马上就释放对象锁，而是在相应的synchronized()&#123;&#125;语句块执行结束，自动释放锁， * JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。 */ try &#123; // 再释放 prev，休眠等待唤醒 prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 创建锁标记 Object a = new Object(); Object b = new Object(); Object c = new Object(); // 三个任务 ThreadPrinter pa = new ThreadPrinter("A", c, a); ThreadPrinter pb = new ThreadPrinter("B", a, b); ThreadPrinter pc = new ThreadPrinter("C", b, c); // 创建三个线程分别把任务扔里面 new Thread(pa).start(); Thread.sleep(10); new Thread(pb).start(); Thread.sleep(10); new Thread(pc).start(); Thread.sleep(10); &#125;&#125;法二：ReentrantLock使用ReentrantLock替代synchronized。ReentrantLock是一个可重入且独占式的锁，它具有与使用synchronized监视器锁相同的基本行为和语义，但与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。ReentrantLock，顾名思义，它是支持可重入锁的锁，是一种递归无阻塞的同步机制。除此之外，该锁还支持获取锁时的公平和非公平选择。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.xwl;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class TestABC &#123; private static int state = 0; // 作为锁 public static void main(String[] args) &#123; final Lock lock = new ReentrantLock(); Thread A = new Thread(new Runnable()&#123; public void run() &#123; while(state&lt;=30)&#123; lock.lock(); if(state%3 == 0)&#123; System.out.println('A'); state++; &#125; lock.unlock(); &#125; &#125; &#125;); Thread B = new Thread(new Runnable()&#123; public void run() &#123; while(state&lt;=30)&#123; lock.lock(); if(state%3 == 1)&#123; System.out.println('B'); state++; &#125; lock.unlock(); &#125; &#125; &#125;); Thread C = new Thread(new Runnable()&#123; public void run() &#123; while(state&lt;=30)&#123; lock.lock(); if(state%3 == 2)&#123; System.out.println('C'); state++; &#125; lock.unlock(); &#125; &#125; &#125;); A.start(); B.start(); C.start(); &#125;&#125;参考链接dadapeng：Java两个线程实现交替运行-以交替打印奇偶数为例之牧_牧之：算法_创建三个线程交替循环打印“A”、”B”、“C”DivineH：Java并发编程之ReentrantLock详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由Java内存机制引发的一些语法问题]]></title>
    <url>%2Fp%2F2027328352%2F</url>
    <content type="text"><![CDATA[i = i++123int i = 0;i = i++;System.out.println("i的值是 "+i);根据我们通常所知道的后自增先使用后增加的道理，i++在使用后i自身会增加一个数值，初始值为0时，自增后就是1，那么输出的结果应该是1.但实际上这题的结果却是0。1i的值是 0这是因为jvm在处理i = i++时， 会建立一个临时变量来接收i++的的值，然后返回这个临时变量的值，返回的值再被等号左边的变量接收了，这样就是说i虽然自增了但是又被赋值了0，这样输出的结果自然就是0了。不妨我们用temp临时变量来接收i++的值，来看一下结果。12345public static void main(String[] args) &#123; int i = 0; int temp = i++; System.out.println("temp的值是 "+temp); &#125;1temp的值是 0可以看到temp的结果就是0，也就是说赋值号右边传递过来的是i未自增前的值，这符合后自增运算符先使用后增加的原则，这时候我们再输出一下i的值。123456public static void main(String[] args) &#123; int i = 0; int temp = i++; System.out.println("temp的值是 "+temp); System.out.println("i的值是 "+i);&#125;12temp的值是 0i的值是 1i也的确自增了一个值，这样就好理解为什么i = i++中输出第一个i为什么是0了，因为i在自增后又被等式右边的值覆盖了。也就是说这里的i的值发生了三次变化，第一次是我们定义i = 0；第二次就是i自增后变成了1；第三次就是i又被0值覆盖了。str= “test ok”123456789101112131415public class Example &#123; String str = new String("good"); char[] ch = &#123;'a','b','c'&#125;; public static void main(String[] args) &#123; Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str +"and"); System.out.print(ex.ch); &#125; public void change(String str, char ch[])&#123; str= "test ok"; ch[0]= 'g'; &#125; &#125;结果：1goodandgbc在change方法中，str被指向了”test ok”，这个方法参数只是原来的全局变量str的一个副本，而原来的str仍然指向“good”。而ch数组被直接修改了堆内存中的值。参考链接人生第一步：java中 i = i++ 的结果牛客网：题目]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组的基本操作]]></title>
    <url>%2Fp%2F3811859892%2F</url>
    <content type="text"><![CDATA[数组的长度时固定的，集合的长度是可变的，数组用来存放基本类型数据，集合用来存放对象的引用，常用的集合有List集合、Set集合和Map集合，其中List与Set继承了Collection接口，各接口还提供了不同的实现类。数组的初始化大致分为两种：静态初始化，动态初始化动态初始化格式：数据类型 [ ] 数组名称 = new 数据类型[数组长度]静态初始化格式：数据类型 [ ] 数组名称 = new 数据类型[ ]{元素1，元素2，元素3…}静态初始化省略格式：数据类型 [ ] 数组名称 = {元素1，元素2，元素3…}其中，数据类型可以是8种基本的数据类型，也可以是引用数据类型。数据类型默认初始化byte、short、int、long0foat、double0.0char一个空字符，即 ‘\u0000’booleanfalse引用数据类型null，表示变量不引用任何对象注意：通过数组下标索取来取得元素，下标默认从0开始。数组下标超出数组长度，数组越界异常（运行时异常）。数组属于引用数据类型，在使用之前一定要开辟空间（实例化），否则就会产生”NullPoninterException”。同一块堆内存空间可以被不同的栈内存所指向。12345678910111213141516171819public class Study02&#123; public static void main(String[] args)&#123; int[] arr = new null; int[] temp = null; // 声明对象 arr = new int[3]; // 开辟一个长度为3的数组 System.out.println(arr.length); arr[0] = 1; // 数组第一个元素 arr[1] = 2; // 数组第二个元素 arr[2] = 3; // 数组第三个元素 for(int i = 0; i &lt; arr.length; i++) &#123; //通过循环控制索引下标更改 System.out.println(arr[i]); &#125; temp = arr; // 发生引用传递，不能出现[] temp[0] = 55; // 修改数据 System.out.println(arr[0]); &#125;&#125;数组的遍历通常可以使用for循环。在不需要对数组进行操作的情况下，使用foreach语句会更简单。123// type:数据类型; var:变量名; iterable:数组的变量名for (type var : iterable) &#123;&#125;数组元素替换可通过Arrays类的静态方法fill()来对数组中的元素进行替换。该方法通过各种重载形式可完成对任意类型的数组元素的替换。fill()方法有两种参数类型。fill(int[ ]a,int value)该方法可将指定的int值分配给int型数组的每一个元素1234567public static void main(String[] args) &#123; int[]arr=new int[5]; Arrays.fill(arr, 6); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println("第"+i+"个元素是："+arr[i]); &#125;&#125;输出：12345第0个元素是：6第1个元素是：6第2个元素是：6第3个元素是：6第4个元素是：6fill(int []a, int fromIndex, int toIndex, int val)该方法将指定的int值分配给int型数组指定范围中的每个元素。填充的范围从索引fromIndex（包括）一直到索引toIndex（不包括）。如果fromIndex==toIndex，则填充范围为空。1234567public static void main(String[] args) &#123; int arr[]=new int[]&#123;1,2,3,4&#125;; Arrays.fill(arr, 1, 2, 5); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println("第"+i+"个元素是"+arr[i]); &#125;&#125;输出：1234第0个元素是1第1个元素是5第2个元素是3第3个元素是4如果指定的索引位置大于或等于要进行填充的数组的长度，则会报ArrayIndexOutOfBoundsException（数组越界异常）异常。数组排序通过Arrays类的静态sort()方法可以实现对数组的排序。sort方法提供了多种重载形式，可对任意类型的数组进行升序排序。1234567public static void main(String[] args) &#123; int arr[]=new int[] &#123;1,5,3,9,8&#125;; Arrays.sort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125;复制数组Arrays类的copyOf()方法与copyOfRange()方法可以实现对数组的复制。copyOf()方法是复制数组至指定长度。copyOfRange()方法是将指定数组的指定长度复制到一个新数组中。copyOf()该方法提供了多种重载形式，用于满足不同类型数组的复制1234567public static void main(String[] args) &#123; int arr[]=new int[] &#123;1,2,3&#125;; int newArr[]=Arrays.copyOf(arr, 5); for (int i = 0; i &lt; newArr.length; i++) &#123; System.out.println(newArr[i]); &#125; &#125;输出：1234512300copyOfRange()多种重载1234567public static void main(String[] args) &#123; int arr[]=new int[] &#123;1,2,3,4,5,6&#125;; int newArr[]=Arrays.copyOfRange(arr, 0, 3); for (int i = 0; i &lt; newArr.length; i++) &#123; System.out.println(newArr[i]); &#125; &#125;数组查询（搜索）Arrays类的binarySearch()方法，可使用二分搜索法来搜索指定数组 ，以获得指定对象。该方法返回要搜索元素的索引值。binarySearch()方法提供了多种重载形式，用于满足各种类型数组的查找需要。binarySearch()方法有两种参数类型。binarySearch(Object [ ],Object key)123456public static void main(String[] args) &#123; int arr[]=new int[] &#123;4,25,10&#125;; Arrays.sort(arr); // 注意此处进行了排序操作 int index=Arrays.binarySearch(arr, 0,1,8); System.out.println(index); &#125;输出：1-2上面的代码中变量index的值是元素8在数组arr中索引在0~1内的索引位置。由于在指定的范围内并不存在元素8，index的值是“-”（插入点）。如果对数组进行排序，元素8应该在25的前面，因此插入点应是元素25的索引值2，所以index的值是-2。如果数组中的所有元素都小于指定的键，则为arr.length。必须在进行此调用之前对数组进行排序（通过sort()方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定索引值的元素，则无法保证找到的是哪一个。binarySearch(Object [ ],int fromIndex,int toIndex,Object key)该方法在指定的范围内检索某一元素。123456public static void main(String[] args) &#123; String str[]=new String[] &#123;"ab","cd","ef","yz"&#125;; Arrays.sort(str); int index=Arrays.binarySearch(str, "cd"); System.out.println("cd的索引位置是："+index); &#125;输出：1cd的索引位置是：1在使用此方法之前同样对数组进行排序，来获取准确的索引值。如果要搜索的元素key在指定的范围内，则返回搜索键的索引；否则返回-1或“-”（插入点）。如果范围中的所有元素都小于指定的键，则为toIndex。如果指定的范围大于或等于数组的长度，则会报出ArrayIndexOutOfBoundsException异常。向数组添加元素一般数组是不能添加元素的，因为他们在初始化时就已定好长度了，不能改变长度。声明为ArrayList定义一个ArrayList数组，然后用add(element)方法往里添加元素即可，还可add(index,element)往指定下标处添加元素。1List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();先把array转化为list，用list的add()方法添加元素，再把list转化为array这儿会有一个陷阱盲区，在把array转化为list的过程中，使用的asList()方法会返回一个final的,固定长度的ArrayList类，并不是java.util.ArrayList，直接这样利用它进行add()或remove()是无效的。123List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();list=Arrays.asList(sz);list.add(5);这里应该在定义list的时候就直接对array进行转化，代码如下：（注意这儿Array类型是包装类，若是一般数据类型记得转化）123456Integer []sz=&#123;3,2&#125;;List&lt;Integer&gt; list=new ArrayList(Arrays.asList(sz));//**须定义时就进行转化**list.add(1,5);Integer[] nsz=new Integer[list.size()];list.toArray(nsz);System.out.println(Arrays.toString(nsz));使用上面所说的copyOf()方法，新元素的大小为旧元素的大小+1，再在新元素里添加即可。参考链接下雨听风：JAVA中数组的初始化lemon_fight：Java中数组的定义及初始化跟着BOSS有肉吃：Java数组的基本操作hepburns：Java中集合类和数组的区别]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的常用操作(转)]]></title>
    <url>%2Fp%2F2094704911%2F</url>
    <content type="text"><![CDATA[Git常用命令记录总结，转载自廖雪峰的Git教程。原教程十分详尽，这里摘录去除了一些我觉得不重要的内容，如果看的不尽兴可以点开链接。Git简介Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。（以下省略一万字的介绍。。。)Git安装如果你正在使用Mac做开发，有两种安装Git的方法。一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。1brew insatll git第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。安装完成后，还需要最后一步设置，在命令行输入：12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;Git本地使用创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单。首先，选择一个合适的地方，创建一个空目录：1234$ mkdir learngit$ cd learngit$ pwd/Users/xxx/learngitpwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/xxx/learngit。如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。通过git init命令把这个目录变成Git可以管理的仓库12$ git initInitialized empty Git repository in /Users/xxx/learngit/.git/瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository）。可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。把文件添加到版本库所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。编写一个readme.txt文件，内容如下：12Git is a version control system.Git is free software.一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。用命令git commit告诉Git，把文件提交到仓库：1234$ git commit -m "wrote a readme file"[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txtgit commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m "add 3 files."你也可以使用git add .一次性add所有文件。Git commit规范在一些项目里，会使用commitlint和husky在git push 代码之前检测commit messages，此时我们需要采用一定的commit规范：1&lt;type&gt;: &lt;subject&gt;注意冒号后面有空格。type用于说明 commit 的类别，只允许使用下面7个标识。feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。subjectsubject是 commit 目的的简短描述，不超过50个字符，且结尾不加句号（.）。查看工作状态我们已经成功地添加并提交了一个readme.txt文件，现在，我们继续修改readme.txt文件，改成如下内容：12Git is a distributed version control system.Git is free software.运行git status命令看看结果：123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a")git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。用git diff这个命令查看具体修改内容。git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，git add和git commit。提交后，我们再用git status命令看看仓库的当前状态：123$ git statusOn branch masternothing to commit, working tree cleanGit告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。版本回退用git log命令查看从最近到最远的提交日志。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数。一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字。在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：12$ git reset --hard HEAD^HEAD is now at e475afc add distributedgit reset —hard xxxx：彻底回退版本，连本地文件都会被回退到上个版本的内容git reset —sort xxxx：只回退commit，如果你想再次提交直接git commit即可还可以继续回退到上一个版本，不过且慢，然我们用git log再看看现在版本库的状态，最新的那个版本已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。再小心翼翼地看看readme.txt的内容：123$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.果然，我胡汉三又回来了。Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：123456789┌────┐│HEAD│└────┘ │ └──&gt; ○ append GPL │ ○ add distributed │ ○ wrote a readme file改为指向add distributed：123456789┌────┐│HEAD│└────┘ │ │ ○ append GPL │ │ └──&gt; ○ add distributed │ ○ wrote a readme file然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。工作区和暂存区先来看名词解释。工作区（Working Directory）就是你在电脑里能看到的目录。版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。你可以简单理解为，需要提交的文件修改通通放到暂存区（add），然后，一次性提交（commit）暂存区的所有修改。Git跟踪并管理的是修改，而非文件。因此，位添加到暂存区的修改是不能提交的。撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。删除文件一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：1$ rm test.txt现在你有两个选择：确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：1$ git checkout -- test.txtgit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。Git远程添加远程库先有本地库，后有远程库的时候，如何关联远程库：要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。从远程库客隆先创建远程库，然后，从远程库克隆：知道仓库的地址，然后使用git clone命令克隆创建和合并分支查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;git checkout命令加上-b参数表示创建并切换创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。删除分支：git branch -d &lt;name&gt;分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式（使用--no-ff参数），Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。1git merge --no-ff -m "merge with no-ff" dev因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。Bug分支当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支；修复完成后，切换到master分支，并完成合并，最后删除临时分支。回到dev分支，用git stash list命令看看：12$ git stash liststash@&#123;0&#125;: WIP on dev: f52c633 add merge工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了。你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：1$ git stash apply stash@&#123;0&#125;多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote：12$ git remoteorigin或者，用git remote -v显示更详细的信息：123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push)上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：1$ git push origin master如果要推送其他分支，比如dev，就改成：1$ git push origin dev但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。多人协作的工作模式通常是这样：首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。自定义Git忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore忽略文件的原则是：忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。配置别名我们只需要敲一行命令，告诉Git，以后st就表示status：1$ git config --global alias.st status好了，现在敲git st看看效果。当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：123$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch以后提交就可以简写成：1$ git ci -m &quot;bala bala bala...&quot;--global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。配置文件配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：12345678910111213141516$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[alias] last = log -1别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：123456789$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。]]></content>
      <tags>
        <tag>转载</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个简单的RSS阅读器]]></title>
    <url>%2Fp%2F1925762643%2F</url>
    <content type="text"><![CDATA[Github链接:RSS在此项目的分支下有个release可以测试原因随着智能手机的普及，人们从智能终端获取新闻资讯的需求逐渐增加，用手机看新闻、报纸、刊物等已经成为大多数人每天必做的事情之一。人们迫切地希望可以有一款能随时提供最新资讯、重大新闻，可以将用户个性化订阅的新闻、报纸、刊物等快速、准确、方便地推送到智能手机用户的新闻资讯阅读软件。当然其实是因为Android的课设给了一堆题目，又因为即刻的关系，自然而然选了RSS阅读器。以下其实是课设报告的版本…所以看上去可能不是那么舒服功能描述新闻组的管理用户能按照自己的需求来对新闻组进行CRUD等基本操作；RSS新闻频道的管理用户能够按照自己的需求对RSS新闻频道进行增删改查等基本功能的实现；新闻频道阅读：当用户打开一个RSS新闻频道时，能够准确无误的从网络上加载该频道的新闻列表；新闻信息的阅读：当用户觉得某一条新闻有趣时，能够打开新闻显示界面进行概要浏览，还能进去具体网页进行更为详细的了解；新闻的更新：当RSS更新以后，程序能做相应的更新，能与网络上的内容保持一致性。做到即时更新；新闻的分享：当用户认定某一条新闻比较有趣的时候，可用与别人通过SMS短信进行分享。开发及运行环境开发平台：Android开发语言：Java（1.6以上）开发工具：Android Studio（3.2以上）构建工具：Gradle（3.4以上）数据库系统：SQLite（3.0）详细功能划分基于团队人数少，项目结构紧凑等特点，将上面六点主要功能划分为总计个功能点，6类任务划分。(其实是因为一组有六个人)应用基础应用主题框架；数据库（表）设计及生成；RSS源的解析；实体类；数据库协作类接口及实现；订阅页及item页显示已订阅的RSS源；刷新RSS源的数据（主动刷新|定时刷新）；添加RSS源数据到本地；点击某个RSS跳转到item页；item页显示该RSS下的所有item；点击某个item跳转到详情页；详情页根据item的url加载内容；直接在浏览器打开该url；收藏到本地|从本地取消收藏；调用系统api分享此url；发现页显示数据库中所有的RSS源及对应信息；根据订阅状态显示不同图标；更改订阅状态；搜索RSS源；我的页设置应用阅读字体大小；进入收藏页并显示收藏的文章信息；点击收藏item进入详情页；长按及分组订阅页长按订阅界面项跳出选项（取消订阅，更改分组，删除此项）；发现页长按跳出更改分组，添加分组选项；我的页点击“我的分组”显示RSS源的分组信息。人员团队成员共6人，故将上面的6个任务分别作安排。这样划分可以保证每个人可以在一定程度上单独开发模块，同时可以使用Github来保证项目的一致性（说实话这是我第一次在课设的时候用Github，确实更节省很多不必要的功夫）个人任务应用主题框架应用主题框架采用BottomNavigationBar+ViewPager+Fragment组合，实现结果和微信等主流应用类似，比较美观易用。MainActivity中仅有1个BottomNavigationView和1个ViwePager组件，在代码中给Bar挂载上bottom menu。1234567891011@Overridepublic void onPageSelected(int position) &#123; if (menuItem != null) &#123; menuItem.setChecked(false); &#125; else &#123; bottomNavigationView.getMenu().getItem(0).setChecked(false); &#125; menuItem = bottomNavigationView.getMenu().getItem(position); menuItem.setChecked(true);&#125;menu的样式和效果在对应的xml文件中定义。ViewPager添加3个Fragment。12345678private void setupViewPager(ViewPager viewPager) &#123; ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); adapter.addFragment(SubscribeFragment.newInstance()); adapter.addFragment(FindFragment.newInstance("1","2")); adapter.addFragment(MyFragment.newInstance("1","2")); viewPager.setAdapter(adapter);&#125;效果：实体类订阅页需要的数据为：已订阅RSS的名字，RSS的消息数；发现页需要的数据为：所有的RSS的name，url，订阅状态，分组；item页需要的数据为：某个RSS的name，item的title，description和time（图片不考虑）；详情页需要的数据为：所属RSS的title，item的url和time；收藏页需要的数据为：已收藏的item的RSS的url，title，description和收藏时间。结合以上，设计三个实体类：RSSUrl12345int id;String url;String name;String groupName;// 新闻组SubscribeStatus status;// 是否订阅RSSItemBean12345678910// 标题private String title;// 发布者（为自定义name时默认为它）private String author;// 详情链接private String link;// 网站或栏目的简要介绍private String description;// 时间private Date pubDate;FavorRSSItem123456// 此item的urlprivate String itemUrl;private String titleName;private String description;// 收藏时间private String favorTime;RSS源的解析RSS是基于XML(可扩展标志语言)的一种形式，并且所有的RSS文件都要遵守万维网联盟(W3C)站点发布的XML 1.0规范。一般来说，RSS文档的最顶层是一个元素作为根元素，元素有一个强制属性version，用于指定当前RSS文档的版本，目前常用的RSS版本是2.0。元素下的子元素是唯一的一个元素，它包含了关于该网站或栏目的信息和内容，在下必备的语句有三个：：网站或栏目的名称，一般与网站或栏目的页面title一致；：网站或栏目的URL；：对网站或栏目的简要描述。还可以使用一些如(语言)、(版权声明)等可选语句来丰富&lt; channel&gt;内容，具体的新闻提要就要依靠来体现了。一般一条新闻就是一个，&lt; item&gt;下至少要存在一个或，其他语句可以根据需要进行选择。一般一个RSS文件如下例：123456789101112131415161718&lt;?xml version="1.0" encoding="gb2312"?&gt;&lt;rss version="2.0"&gt; &lt;channel&gt; &lt;title&gt;网站或栏目的名称&lt;/title&gt; &lt;link&gt;网站或栏目的URL地址&lt;/link&gt; &lt;description&gt;网站或栏目的简要介绍&lt;/description&gt; &lt;item&gt; &lt;title&gt;新闻标题&lt;/title&gt; &lt;link&gt;新闻的链接地址&lt;/link&gt; &lt;description&gt;新闻简要介绍&lt;/description&gt; &lt;pubDate&gt;新闻发布时间&lt;/pubDate&gt; &lt;author&gt;新闻作者名称&lt;/author&gt; &lt;/item&gt; &lt;item&gt; ...... &lt;/item&gt; &lt;/channel&gt;&lt;/rss&gt;但是各个RSS源的xml文档可能都有自己的特点，为了保证解析的简单稳定，我引入了一个专门用于帮助解析xml的包：Rome。在utils包中，我设计了一个RSSUtil类，通过设置rss的url，并使用rome的一些类来获取title，link，description，item等数据，并提供get方法。123456789101112131415private void parseFromUrl(String url) throws IOException, FeedException &#123; SyndFeedInput input = new SyndFeedInput(); URLConnection connection = new URL(url).openConnection(); // 防止403 connection.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)"); String contentEncoding = connection.getHeaderField("Content-Encoding"); if (contentEncoding != null &amp;&amp; contentEncoding.contains("gzip")) &#123; // System.out.println("content encoding is gzip"); GZIPInputStream gzipInputStream = new GZIPInputStream(connection.getInputStream()); feed = input.build(new XmlReader(gzipInputStream)); &#125; else &#123; feed = input.build(new XmlReader(connection.getInputStream())); &#125;&#125;文章数：rssUtil.getFeedSize()RSS标题：rssUtil.getTitleName()RSS描述: rssUtil.getDescription()文章项：rssUtil.getRssItemBeans()为了保证数据在不影响主线程的情况下获取到，调用parseFromUrl()方法在新线程中，并使用CountDownLatch保证该线程已经被执行完成。123456789101112131415private void getRSSData(final String rssUrl) &#123; final CountDownLatch cdl = new CountDownLatch(1); new Thread(new Runnable() &#123; @Override public void run() &#123; doParse(rssUrl); cdl.countDown(); &#125; &#125;).start(); try &#123; cdl.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;数据库（表）设计及生成三个实体类中需要持久化的仅为RSSUrl和FavorRSSItem，因此基于他们的属性设计以下数据库：数据库协作类接口及实现数据库接口在后来的模块合并过程中增加了一些，增加的几个并没有在下面列出（因为过了一段时间忘了加了哪些了，可以参见源码）DatabaseHelper类继承SQLiteOpenHelper用于数据库和表的创建工作，并对外提供getWritableDatabase()和getReadableDatabase()方法。BaseDALImpl类数据库DAL基类，预设一些方法和成员，并提供preInsertRssUrl()将来自xml中的一些内置的RSS url链接杀入到RSS_URL表中。该方法在线程PreDatabaseThread的run()方法中被调用。1234@Overridepublic void run() &#123; new BaseDALImpl(context).preInsertRssUrl();&#125;在MainActivity中start该线程。12preDatabaseThread=new PreDatabaseThread(getApplicationContext());new Thread(preDatabaseThread).start();FavorRSSItemDAL类favor_rss_item表协作类接口，共以下5个接口。显示所有收藏123456/** * 查询表favor_rss_item全部内容 * @param favorRSSItems 必须保证传进 Adapter 的数据 List 是同一个 List * @return rssUrlArrayList */ArrayList&lt;FavorRSSItem&gt; getAllData(ArrayList&lt;FavorRSSItem&gt; favorRSSItems);查询收藏1234567/** * 模糊查询|不实现 * @param rssUrlArrayList 必须保证传进 Adapter 的数据 List 是同一个 List * @param query 输入的字符串 * @return rssUrlArrayList */ArrayList&lt;FavorRSSItem&gt; getQueryData(ArrayList&lt;FavorRSSItem&gt; rssUrlArrayList, String query);查询某项item123456/** * 查询favor_rss_item某一项的内容 * @param id 选中项的id * @return 一项item */FavorRSSItem getOneData(Integer id);收藏12345678/** * 收藏 * @param url 该item的url * @param titleName 标题 * @param description 描述 * @return 是否添加成功 */long insertOneData(String url,String titleName,String description);取消收藏123456/** * 取消收藏 * @param id 选中项的id * @return 一项item */int deleteOneData(Integer id);RSSUrlDAL类rss_url表协作类接口，共以下9个接口。查询所有123456/** * 查询表rss_url全部内容 * @param rssUrlArrayList 必须保证传进 Adapter 的数据 List 是同一个 List * @return rssUrlArrayList */ArrayList&lt;RSSUrl&gt; getAllData(ArrayList&lt;RSSUrl&gt; rssUrlArrayList);获取所有已订阅内容1ArrayList&lt;RSSUrl&gt; getSubscribe(ArrayList&lt;RSSUrl&gt; rssUrls);模糊查询1234567/** * 模糊查询 * @param rssUrlArrayList 必须保证传进 Adapter 的数据 List 是同一个 List * @param query 输入的字符串 * @return rssUrlArrayList */ArrayList&lt;RSSUrl&gt; getQueryData(ArrayList&lt;RSSUrl&gt; rssUrlArrayList, String query);查询rss_url某一项的内容123456/** * 查询rss_url某一项的内容 * @param id 选中项的id * @return 一项item */RSSUrl getOneData(Integer id);添加12345678/** * 添加一个rss源 * @param url rss url * @param groupName 组名，default="" * @param status 订阅状态，主动添加时default=SUBSCRIBED * @return 是否添加成功 */long insertOneData(String url, String groupName, SubscribeStatus status);添加123456/** * 删除某项 * @param id 选中项的id * @return 一项item */int deleteOneData(Integer id);更改标题名1234567/** * 更改标题名 * @param id 选中项的id * @param name 新的名字 * @return 是否成功 */int updateName(Integer id, String name);更改组名1234567/** * 更改组名 * @param id 选中项的id * @param groupName 新的组名 * @return 是否成功 */int updateGroupName(Integer id, String groupName);更改订阅状态1234567/** * 更改订阅状态 * @param id 选中项的id * @param status 订阅状态 * @return */int updateSubscribeStatus(Integer id,SubscribeStatus status);补充RSS解析的时间格式和收藏时插入数据库的时间格式均需要重新解析，转化为自己想要的格式；因为RSS源的问题，会有数据空（titleName）和带html格式（description）的问题，前者已通过判断设值的方式完成。1234567891011/** * 获取标题，title为空时设为unknown * @return */public String getTitleName() &#123; titleName=feed.getTitle(); if(titleName==null||titleName.isEmpty())&#123; titleName="unknown"; &#125; return titleName;&#125;后者未完全实现。123public String getDescription() &#123; return ClearStringUtil.clearDescription(feed.getDescription());&#125;可能因为RSSItem数据量过大而影响性能，但暂时未使用分批查询模式；为了匹配某项以.xml结尾的rss源，增加url匹配；1234567891011private void doParse(String rssUrl) &#123; if(!rssUrl.startsWith("https://")&amp;&amp;!rssUrl.startsWith("http://"))&#123; System.out.println("add https:// for url"); rssUrl="https://"+rssUrl; &#125; if (rssUrl.endsWith(".xml")) &#123; ... &#125; else &#123; ... &#125;&#125;数据库的增删改操作均有返回值，以判断是否执行成功。总结模块式的任务划分确实能提高工作效率，减少工作负担；开发供其他人使用的接口时要描述清楚功能和参数；开发环境尽量保持相同，否则会浪费大量时间和精力。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring Boot框架-1-了解基本概念]]></title>
    <url>%2Fp%2F3907919010%2F</url>
    <content type="text"><![CDATA[什么是Spring BootSpring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要是简化了使用Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。独立运行Spring Boot而且内嵌了各种servlet容器，如Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。这里额外补充一下什么是servlet和servlet容器：Java Servlet（Java服务器小程序）是一个基于Java技术的Web组件，运行在服务器端，它由Servlet容器所管理，用于生成动态的内容。Servlet是平台独立的Java类，编写一个Servlet，实际上就是按照Servlet规范编写一个Java类。Servlet被编译为平台独立的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。Servlet容器也叫做Servlet引擎，是Web服务器或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务，解码基于MIME的请求，格式化基于MIME的响应。Servlet没有main方法，不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用Servlet的方法（如doGet()和doPost()），Servlet容器在Servlet的生命周期内包容和管理Servlet。在JSP技术推出后，管理和运行Servlet/JSP的容器也称为Web容器。注：常用的MIME类型：text/html，application/pdf，video/quicktime，application/java，image/jpeg，application/jar，application/octet-stream，application/x-zip有了servlet之后，用户通过单击某个链接或者直接在浏览器的地址栏中输入URL来访问Servlet，Web服务器接收到该请求后，并不是将请求直接交给Servlet，而是交给Servlet容器。Servlet容器实例化Servlet，调用Servlet的一个特定方法对请求进行处理，并产生一个响应。这个响应由Servlet容器返回给Web服务器，Web服务器包装这个响应，以HTTP响应的形式发送给Web浏览器。简化配置spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。自动配置Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。无代码生成和xml配置Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。应用监控Spring Boot提供一系列端点可以监控服务及应用，做健康检测。Spring Boot 的核心配置文件Spring Boot 的核心配置文件是 application (.yml 或者 .properties)和 bootstrap (.yml 或者 .properties)配置文件。注：.yml格式不支持@PropertySource 注解导入配置。bootstrap/ application 的区别Spring Cloud 构建于 Spring Boot 之上，在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。因此，对比 application 配置文件，bootstrap 配置文件具有以下几个特性。boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载boostrap 里面的属性不能被覆盖bootstrap/ application 的应用场景application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。bootstrap 配置文件有以下几个应用场景。使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；一些固定的不能被覆盖的属性；一些加密/解密的场景；Spring Boot 的核心注解启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。@ComponentScan：Spring组件扫描。Spring Boot的目录结构123456789101112131415cn +- javastack +- MyApplication.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java这个目录结构是主流及推荐的做法，而在主入口类上加上 @SpringBootApplication 注解来开启 Spring Boot 的各项能力，如自动配置、组件扫描等。（这么看来我之前的那个项目要重新组织目录结构了）Spring Boot 中的 StartersStarters是什么Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA访问数据库，只要加入spring-boot-starter-data-jpa启动器依赖就能使用了。Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。Starters命名Spring Boot官方的启动器都是以spring-boot-starter-命名的，代表了一个特定的应用类型。第三方的启动器不能以spring-boot开头命名，它们都被Spring Boot官方保留。一般一个第三方的应该这样命名，像mybatis的mybatis-spring-boot-starter。Spring Boot实现热部署首先来看看 JAVA 热部署与热加载的联系：都可以不重启服务器的情况下进行编译/部署项目；基于 Java 的类加载器实现热部署与热加载的区别：热部署在服务器运行时重新部署项目热加载在运行时重新加载 class （字节码文件）只加载重新修改后的类（class 文件）热部署会重新加载整个应用热加载在运行时重新加载 class可以理解为 JVM 启动后会启动一个后台线程，定时来监控文件的时间戳，如果变化就将类重新载入热部署更多在生产环境下使用，热加载多在开发环境下使用（热加载无法记录“热加载执行的日志”）在Spring Boot实现代码热部署是一件很简单的事情，代码的修改可以自动部署并重新热启动项目。引用devtools依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;这样，当修改一个Java类时就会热更新。自定义配置热部署以下配置用于自定义配置热部署，可以不设置。12345# 热部署开关，false即不启用热部署spring.devtools.restart.enabled: true# 指定热部署的目录#spring.devtools.restart.additional-paths: src/main/java# 指定目录不更新spring.devtools.restart.exclude: test/**Intellij Idea修改如果是idea，需要改以下两个地方：1、勾上自动编译或者手动重新编译File &gt; Settings &gt; Compiler-Build Project automatically2、注册ctrl + shift + alt + / &gt; Registry &gt; 勾选Compiler autoMake allow when app runningSpring Boot 配置加载顺序详解使用 Spring Boot 会涉及到各种各样的配置，如开发、测试、线上就至少 3 套配置信息了。Spring Boot 可以轻松的帮助我们使用相同的代码就能使开发、测试、线上环境使用不同的配置。在 Spring Boot 里面，可以使用以下几种方式来加载配置。本章内容基于 Spring Boot 2.0 进行详解。1、properties文件；2、YAML文件；3、系统环境变量；4、命令行参数；等等……配置属性加载的顺序如下：1、开发者工具 Devtools 全局配置参数；2、单元测试上的 @TestPropertySource 注解指定的参数；3、单元测试上的 @SpringBootTest 注解指定的参数；4、命令行指定的参数，如 java -jar springboot.jar --name=&quot;Java技术栈&quot;；5、命令行中的 SPRING_APPLICATION_JSONJSON 指定参数, 如 java -Dspring.application.json=&#39;{&quot;name&quot;:&quot;Java技术栈&quot;}&#39; -jar springboot.jar6、ServletConfig 初始化参数；7、ServletContext 初始化参数；8、JNDI参数（如 java:comp/env/spring.application.json）；9、Java系统参数（来源：System.getProperties()）；10、操作系统环境变量参数；11、RandomValuePropertySource 随机数，仅匹配：ramdom.*；12、JAR包外面的配置文件参数（application-{profile}.properties（YAML））13、JAR包里面的配置文件参数（application-{profile}.properties（YAML））14、JAR包外面的配置文件参数（application.properties（YAML））15、JAR包里面的配置文件参数（application.properties（YAML））16、@Configuration配置文件上 @PropertySource 注解加载的参数；17、默认参数（通过 SpringApplication.setDefaultProperties 指定）；数字小的优先级越高，即数字小的会覆盖数字大的参数值，我们来实践下，验证以上配置参数的加载顺序。1、在主应用程序中添加 Java 系统参数。123456@Beanpublic CommandLineRunner commandLineRunner() &#123; return (args) -&gt; &#123; System.setProperty("name", "javastack-system-properties"); &#125;;&#125;2、在 application.properties 文件中添加属性。1name = javastack-application3、在 application-dev.properties 文件中添加属性。1name = javastack-application-dev4、添加测试类1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(value = &#123; "name=javastack-test", "sex=1" &#125;)@ActiveProfiles("dev")public class SpringBootBestPracticeApplicationTests &#123; @Value("$&#123;name&#125;") private String name; @Test public void test() &#123; System.out.println("name is " + name); &#125;&#125;运行 test 单元测试，程序输出：1name is javastack-test根据以上参数动态调整，发现参数会被正确被覆盖。了解了 Spring Boot 各种配置的加载顺序，如果配置被覆盖了我们就知道是什么问题了。参考文献Java技术栈：吐血整理 20 道 Spring Boot 面试题，我经常拿来面试别人！Java技术栈：什么是Spring Boot?_iAm333：Servlet&amp;JSP的那些事儿（一）喜东东：SpringBoot热部署简介Java技术栈：Spring Boot实现热部署Java技术栈：Spring Boot 配置加载顺序详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java注解(Annotation)]]></title>
    <url>%2Fp%2F1330414162%2F</url>
    <content type="text"><![CDATA[转载，原文链接：秒懂，Java 注解 （Annotation）你可以这样学引言我个人认为，比较糟糕的技术文档主要特征之一就是：用专业名词来介绍专业名词。比如：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。这是大多数网站上对于 Java 注解，解释确实正确，但是说实在话，我第一次学习的时候，头脑一片空白。这什么跟什么啊？听了像没有听一样。因为概念太过于抽象，所以初学者实在是比较吃力才能够理解，然后随着自己开发过程中不断地强化练习，才会慢慢对它形成正确的认识。我在写这篇文章的时候，我就在思考。如何让自己或者让读者能够比较直观地认识注解这个概念？是要去官方文档上翻译说明吗？我马上否定了这个答案。后来，我想到了一样东西————墨水，墨水可以挥发、可以有不同的颜色，用来解释注解正好。不过，我继续发散思维后，想到了一样东西能够更好地代替墨水，那就是印章。印章可以沾上不同的墨水或者印泥，可以定制印章的文字或者图案，如果愿意它也可以被戳到你任何想戳的物体表面。但是，我再继续发散思维后，又想到一样东西能够更好地代替印章，那就是标签。标签是一张便利纸，标签上的内容可以自由定义。常见的如货架上的商品价格标签、图书馆中的书本编码标签、实验室中化学材料的名称类别标签等等。并且，往抽象地说，标签并不一定是一张纸，它可以是对人和事物的属性评价。也就是说，标签具备对于抽象事物的解释。所以，基于如此，我完成了自我的知识认知升级，我决定用标签来解释注解。注解如同标签回到博文开始的地方，之前某新闻客户端的评论有盖楼的习惯，于是 “乔布斯重新定义了手机、罗永浩重新定义了傻X” 就经常极为工整地出现在了评论楼层中，并且广大网友在相当长的一段时间内对于这种行为乐此不疲。这其实就是等同于贴标签的行为。在某些网友眼中，罗永浩就成了傻X的代名词。广大网友给罗永浩贴了一个名为“傻x”的标签，他们并不真正了解罗永浩，不知道他当教师、砸冰箱、办博客的壮举，但是因为“傻x”这样的标签存在，这有助于他们直接快速地对罗永浩这个人做出评价，然后基于此，罗永浩就可以成为茶余饭后的谈资，这就是标签的力量。而在网络的另一边，老罗靠他的人格魅力自然收获一大批忠实的拥泵，他们对于老罗贴的又是另一种标签。老罗还是老罗，但是由于人们对于它贴上的标签不同，所以造成对于他的看法大相径庭，不喜欢他的人整天在网络上评论抨击嘲讽，而崇拜欣赏他的人则会愿意挣钱购买锤子手机的发布会门票。我们可以抽象概括一下，标签是对事物行为的某些角度的评价与解释。到这里，终于可以引出本文的主角注解了。初学者可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。在未开始学习任何注解具体语法而言，你可以把注解看成一张标签。这有助于你快速地理解它的大致作用。如果初学者在学习过程有大脑放空的时候，请不要慌张，对自己说：注解，标签。注解，标签。注解的基本语法因为平常开发少见，相信有不少的人员会认为注解的地位不高。其实同 classs 和 interface 一样，注解也属于一种类型。它是在 Java SE 5.0 版本中开始引入的概念。注解的定义注解通过 @interface关键字进行定义。12public @interface TestAnnotation &#123;&#125;它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 TestAnnotaion 的注解。你可以简单理解为创建了一张名字为 TestAnnotation 的标签。注解的应用上面创建了一个注解，那么注解的的使用方法是什么呢?123@TestAnnotationpublic class Test &#123;&#125;创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。你可以简单理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。元注解元注解是什么意思呢？元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。元标签有@Retention、@Documented、@Target、@Inherited、@Repeatable5 种。@RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。它的取值如下：RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。我们可以这样的方式来加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签张贴的时间。@Retention 相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。123@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125;上面的代码中，我们指定 TestAnnotation 可以在程序运行周期被获取到，因此它的生命周期非常的长。@Documented顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。@TargetTarget 是目标的意思，@Target 指定了注解运用的地方。你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值ElementType.ANNOTATION_TYPE 可以给一个注解进行注解ElementType.CONSTRUCTOR 可以给构造方法进行注解ElementType.FIELD 可以给属性进行注解ElementType.LOCAL_VARIABLE 可以给局部变量进行注解ElementType.METHOD 可以给方法进行注解ElementType.PACKAGE 可以给一个包进行注解ElementType.PARAMETER 可以给一个方法内的参数进行注解ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举@InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。说的比较抽象。代码来解释。12345678910@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125;注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。可以这样理解：老子非常有钱，所以人们给他贴了一张标签叫做富豪。老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。老子的孙子长大了，自然也是富豪。这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。@RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。什么样的注解会多次应用呢？通常是注解的值可以同时取多个。举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。1234567891011121314151617@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default "";&#125;@Person(role="artist")@Person(role="coder")@Person(role="PM")public class SuperMan&#123; &#125;注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。我们再看看代码中的相关容器注解。123@interface Persons &#123; Person[] value();&#125;按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签。我们可能对于 @Person(role=“PM”) 括号里面的内容感兴趣，它其实就是给 Person 这个注解的 role 属性赋值为 PM ，大家不明白正常，马上就讲到注解的属性这一块。注解的属性注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg();&#125;上面代码定义了 TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。1234@TestAnnotation(id=3,msg="hello annotation")public class Test &#123;&#125;需要注意的是，在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组。注解中属性可以有默认值，默认值需要用 default 关键值指定。比如：123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; public int id() default -1; public String msg() default "Hi";&#125;TestAnnotation 中 id 属性默认值为 -1，msg 属性默认值为 Hi。它可以这样应用。12@TestAnnotation()public class Test &#123;&#125;因为有默认值，所以无需要再在 @TestAnnotation 后面的括号里面进行赋值了，这一步可以省略。另外，还有一种情况。如果一个注解内仅仅只有一个名字为 value 的属性时，应用这个注解时可以直接接属性值填写到括号内。123public @interface Check &#123; String value();&#125;上面代码中，Check 这个注解只有 value 这个属性。所以可以这样应用。12@Check("hi")int a;这和下面的效果是一样的12@Check(value="hi")int a;最后，还需要注意的一种情况是一个注解没有任何属性。比如1public @interface Perform &#123;&#125;那么在应用这个注解的时候，括号都可以省略。12@Performpublic void testMethod()&#123;&#125;Java 预置的注解学习了上面相关的知识，我们已经可以自己定义一个注解了。其实 Java 语言本身已经提供了几个现成的注解。@Deprecated这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。123456789101112public class Hero &#123; @Deprecated public void say()&#123; System.out.println("Noting has to say!"); &#125; public void speak()&#123; System.out.println("I have a dream!"); &#125;&#125;定义了一个 Hero 类，它有两个方法 say() 和 speak() ，其中 say() 被 @Deprecated 注解。然后我们在 IDE 中分别调用它们。可以看到，say() 方法上面被一条直线划了一条，这其实就是编译器识别后的提醒效果。@Override这个大家应该很熟悉了，提示子类要复写父类中被 @Override 修饰的方法@SuppressWarnings阻止警告的意思。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。123456@SuppressWarnings("deprecation")public void test1()&#123; Hero hero = new Hero(); hero.say(); hero.speak();&#125;@SafeVarargs参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。1234567@SafeVarargs // Not actually safe! static void m(List&lt;String&gt;... stringLists) &#123; Object[] array = stringLists; List&lt;Integer&gt; tmpList = Arrays.asList(42); array[0] = tmpList; // Semantically invalid, but compiles without warnings String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!&#125;上面的代码中，编译阶段不会报错，但是运行时会抛出 ClassCastException 这个异常，所以它虽然告诉开发者要妥善处理，但是开发者自己还是搞砸了。Java 官方文档说，未来的版本会授权编译器对这种不安全的操作产生错误警告。@FunctionalInterface函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。函数式接口 (Functional Interface) 就是一个具有一个方法的普通接口。比如123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125;我们进行线程开发中常用的 Runnable 就是一个典型的函数式接口，上面源码可以看到它就被 @FunctionalInterface 注解。可能有人会疑惑，函数式接口标记有什么用，这个原因是函数式接口可以很容易转换为 Lambda 表达式。这是另外的主题了，有兴趣的同学请自己搜索相关知识点学习。注解的提取博文前面的部分讲了注解的基本语法，现在是时候检测我们所学的内容了。我通过用标签来比作注解，前面的内容是讲怎么写注解，然后贴到哪个地方去，而现在我们要做的工作就是检阅这些标签内容。 形象的比喻就是你把这些注解标签在合适的时候撕下来，然后检阅上面的内容信息。要想正确检阅注解，离不开一个手段，那就是反射。注解与反射注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;&#125;然后通过 getAnnotation() 方法来获取 Annotation 对象。1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125;或者是 getAnnotations() 方法。1public Annotation[] getAnnotations() &#123;&#125;前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如1234567891011121314151617@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; &#125;&#125;程序的运行结果是：12id:-1msg:这个正是 TestAnnotation 中 id 和 msg 的默认值。上面的例子中，只是检阅出了注解在类上的注解，其实属性、方法上的注解照样是可以的。同样还是要假手于反射。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@TestAnnotation(msg="hello")public class Test &#123; @Check(value="hi") int a; @Perform public void testMethod()&#123;&#125; @SuppressWarnings("deprecation") public void test1()&#123; Hero hero = new Hero(); hero.say(); hero.speak(); &#125; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); //获取类的注解 System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; try &#123; Field a = Test.class.getDeclaredField("a"); a.setAccessible(true); //获取一个成员变量上的注解 Check check = a.getAnnotation(Check.class); if ( check != null ) &#123; System.out.println("check value:"+check.value()); &#125; Method testMethod = Test.class.getDeclaredMethod("testMethod"); if ( testMethod != null ) &#123; // 获取方法中的注解 Annotation[] ans = testMethod.getAnnotations(); for( int i = 0;i &lt; ans.length;i++) &#123; System.out.println("method testMethod annotation:"+ans[i].annotationType().getSimpleName()); &#125; &#125; &#125; catch (NoSuchFieldException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (SecurityException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (NoSuchMethodException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; &#125;&#125;它们的结果如下：1234id:-1msg:hellocheck value:himethod testMethod annotation:Perform需要注意的是，如果一个注解要在运行时被成功提取，那么 @Retention(RetentionPolicy.RUNTIME) 是必须的。注解的使用场景我相信博文讲到这里大家都很熟悉了注解，但是有不少同学肯定会问，注解到底有什么用呢？对啊注解到底有什么用？我们不妨将目光放到 Java 官方文档上来。文章开始的时候，我用标签来类比注解。但标签比喻只是我的手段，而不是目的。为的是让大家在初次学习注解时能够不被那些抽象的新概念搞懵。既然现在，我们已经对注解有所了解，我们不妨再仔细阅读官方最严谨的文档。注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。注解有许多用处，主要如下：提供信息给编译器： 编译器可以利用注解来探测错误和警告信息编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。运行时的处理： 某些注解可以在程序运行的时候接受代码的提取值得注意的是，注解不是代码本身的一部分。如果难于理解，可以这样看。罗永浩还是罗永浩，不会因为某些人对于他“傻x”的评价而改变，标签只是某些人对于其他事物的评价，但是标签不会改变事物本身，标签只是特定人群的手段。所以，注解同样无法改变代码本身，注解只是某些工具的的工具。还是回到官方文档的解释上，注解主要针对的是编译器和其它工具软件(SoftWare tool)。当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。现在，我们可以给自己答案了，注解有什么用？给谁用？给 编译器或者 APT 用的。如果，你还是没有搞清楚的话，我亲自写一个好了。自定义注解完成某个目的我要写一个测试框架，测试程序员的代码有无明显的异常。—— 程序员 A : 我写了一个类，它的名字叫做 NoBug，因为它所有的方法都没有错误。—— 我：自信是好事，不过为了防止意外，让我测试一下如何？—— 程序员 A: 怎么测试？—— 我：把你写的代码的方法都加上 @Jiecha 这个注解就好了。—— 程序员 A: 好的。NoBug.java1234567891011121314151617181920212223242526272829303132package ceshi;import ceshi.Jiecha;public class NoBug &#123; @Jiecha public void suanShu()&#123; System.out.println("1234567890"); &#125; @Jiecha public void jiafa()&#123; System.out.println("1+1="+1+1); &#125; @Jiecha public void jiefa()&#123; System.out.println("1-1="+(1-1)); &#125; @Jiecha public void chengfa()&#123; System.out.println("3 x 5="+ 3*5); &#125; @Jiecha public void chufa()&#123; System.out.println("6 / 0="+ 6 / 0); &#125; public void ziwojieshao()&#123; System.out.println("我写的程序没有 bug!"); &#125;&#125;上面的代码，有些方法上面运用了 @Jiecha 注解。这个注解是我写的测试软件框架中定义的注解。123456789package ceshi;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface Jiecha &#123;&#125;然后，我再编写一个测试类 TestTool 就可以测试 NoBug 相应的方法了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package ceshi;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class TestTool &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub NoBug testobj = new NoBug(); Class clazz = testobj.getClass(); Method[] method = clazz.getDeclaredMethods(); //用来记录测试产生的 log 信息 StringBuilder log = new StringBuilder(); // 记录异常的次数 int errornum = 0; for ( Method m: method ) &#123; // 只有被 @Jiecha 标注过的方法才进行测试 if ( m.isAnnotationPresent( Jiecha.class )) &#123; try &#123; m.setAccessible(true); m.invoke(testobj, null); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block //e.printStackTrace(); errornum++; log.append(m.getName()); log.append(" "); log.append("has error:"); log.append("\n\r caused by "); //记录测试过程中，发生的异常的名称 log.append(e.getCause().getClass().getSimpleName()); log.append("\n\r"); //记录测试过程中，发生的异常的具体信息 log.append(e.getCause().getMessage()); log.append("\n\r"); &#125; &#125; &#125; log.append(clazz.getSimpleName()); log.append(" has "); log.append(errornum); log.append(" error."); // 生成测试报告 System.out.println(log.toString()); &#125;&#125;测试的结果是：123456789101112345678901+1=111-1=03 x 5=15chufa has error: caused by ArithmeticException/ by zeroNoBug has 1 error.提示 NoBug 类中的 chufa() 这个方法有异常，这个异常名称叫做 ArithmeticException，原因是运算过程中进行了除 0 的操作。所以，NoBug 这个类有 Bug。这样，通过注解我完成了我自己的目的，那就是对别人的代码进行测试。所以，再问我注解什么时候用？我只能告诉你，这取决于你想利用它干什么用。注解应用实例注解运用的地方太多了，因为我是 Android 开发者，所以我接触到的具体例子有下：JUnitJUnit 这个是一个测试框架，典型使用方法如下：123456public class ExampleUnitTest &#123; @Test public void addition_isCorrect() throws Exception &#123; assertEquals(4, 2 + 2); &#125;&#125;@Test 标记了要进行测试的方法 addition_isCorrect().ButterKnifeButterKnife 是 Android 开发中大名鼎鼎的 IOC 框架，它减少了大量重复的代码。123456789101112public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.tv_test) TextView mTv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125;&#125;Retrofit很牛逼的 Http 网络访问框架12345678910public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125;Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .build();GitHubService service = retrofit.create(GitHubService.class);当然，还有许多注解应用的地方，这里不一一列举。总结如果注解难于理解，你就把它类同于标签，标签为了解释事物，注解为了解释代码。注解的基本语法，创建如同接口，但是多了个 @ 符号。注解的元注解。注解的属性。注解主要给编译器及工具类型的软件用的。注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以Springboot为框架的预算管理后端demo]]></title>
    <url>%2Fp%2F2054314647%2F</url>
    <content type="text"><![CDATA[这个项目实际上是我服务计算概论课的一部分，题目要求是：编写简单的旅行预算管理服务的接口并做一个调用它的程序。因为最近正好学习了springboot框架，就以此框架来完成我的作业。Github项目：travel-springboot-demo功能按最开始的想法，有两张表，分别记录预算和记录开支。idtotalintdoubleid,主键，自增长预算金额idmatterspendintvarchardoubleid,主键，自增长开支事项花费金额有四个接口，分别能添加开支，更改预算（实际写的过程中是添加预算记录，然后取id最大的条数），获取预算，获取已开支的总金额。因为只是demo，重点是想体现着两类api的实现过程，所以功能上有些简陋。项目说明项目结构SpendController对外提供接口，接收和发出数据；SpendMapper:数据控制层，和UserMapper.xml一起实现对数据库的操纵ItemSpend,TotalSpend:实体类SpendService：服务层，数据和服务之间的连接，并在SpendServiceImpl中实现application.properties:springboot配置文件，此处仅用户配置数据库及更改端口application.properties123456789101112# 数据库连接uri，最后的demo更改为自己的数据库名spring.datasource.url=jdbc:mysql://localhost:3306/demo# 数据库用户名spring.datasource.username=root# 数据库密码spring.datasource.password=123456mybatis.mapper-locations=classpath*:mapper/*Mapper.xmlspring.jpa.show-sql=true# 运行的端口号server.port=8098实体类放在entity包下，下面以ItemSpend类为例说明：123456789101112131415@Data // 此注解可用于替代getter和setter方法@Entity // 表明此类为实体类@Table(name = "item_spend") // 如果没有此表会新建一张名为“item_spend”的表public class ItemSpend &#123; @Id // 表明此为主键 @Column(name = "id") //表的字段名 private Integer id; @Column(name = "matter") private String spendMatter; @Column(name = "spend") private Float spend;&#125;dao此类下存放操纵数据库的接口，此项目中以Mybatis为例，你也可以使用Jpa等。SpendMapper类和mapper/SpendMapper.xml配合使用，也可以直接采用@Select等注解的形式直接写在SpendMapper中。以List\&lt;ItemSpend\&gt; getItemSpendList()为例：123456789@Mapper //声明此类为mapperpublic interface SpendMapper &#123; ... List&lt;ItemSpend&gt; getItemSpendList(); ...&#125;1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="xyz.somelou.travel.dao.SpendMapper"&gt; &lt;resultMap type="xyz.somelou.travel.entity.ItemSpend" id="spendResultMap"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="spendMatter" column="matter"/&gt; &lt;result property="spend" column="spend"/&gt; &lt;/resultMap&gt; &lt;!-- 返回List型对象，resultMap如果不在xml里列举出来会报错，我也不知道为什么--&gt; &lt;select id="getItemSpendList" resultMap="spendResultMap" parameterType="String"&gt; select * from item_spend; &lt;/select&gt;&lt;/mapper&gt;Service层此层常以接口+实现的方式组织，用于处理从数据库中查询得到的数据和前台发来的请求，以TotalBudget getTotalBudget();为例：1234567891011121314@Service // 声明此类为Service层public class SpendServiceImpl implements SpendService &#123; // 调用mapper @Autowired // 写在字段上，那么就不需要再写setter方法 SpendMapper spendMapper;// 有时编译器会报红，不要管它，实际没有错误 ... @Override public TotalBudget getTotalBudget() &#123; return spendMapper.getTotalBudget(); &#125;&#125;Controller层实现对外的接口，主要是调用者请求数据的解析和被请求数据的内部获取和封装，以/add/budget和/get/budget为例：123456789101112131415161718192021222324@CrossOrigin // 支持跨域@RestController // 声明这是Controller,@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用,也可以只使用@Controller,具体我也不是很清楚@RequestMapping(value = "/api/trip") // 接口（的一部分）public class SpendController &#123; // 使用Service接口 @Autowired private SpendService spendService; // 补充说明接口 @RequestMapping(value = "/add/budget") // @RequestBody Map&lt;String,Object&gt; para即为传来的json // ModelMap返回一个json public ModelMap addBudget(@RequestBody Map&lt;String,Object&gt; param)&#123; ModelMap result=new ModelMap(); TotalBudget totalBudget=new TotalBudget(); totalBudget.setBudget(Float.valueOf(param.get("budget").toString())); spendService.addBudget(totalBudget); result.addAttribute("msg","success"); return result; &#125; ...&#125;这样该方法的对外接口（以在本机运行为例）：http://localhost:8098/api/trip/add/budget已知bug没有进行重复提交的限制，会因为网络卡顿出现重复提交；使用自定义注解@NoRepeatSubmit+Redis|内存缓存的形式解决了重复提交问题原博主刚开始使用的是内存缓存的方法限制刷新时间为2秒，后来有评论提问集群下的如何解决，就又推出了使用Redis的解决方案。该博主GitHub项目：gzz2017gzz/spring-boot2-example,第53/54该文章链接：spring boot 防止重复提交]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-2-可重入锁以及Synchronized的其他基本特性]]></title>
    <url>%2Fp%2F556968818%2F</url>
    <content type="text"><![CDATA[Synchronized锁重入关键字Synchronized拥有锁重入的功能，也就是在使用Synchronized的时候，当一个线程得到一个对象的锁后，在该锁里执行代码的时候可以再次请求该对象的锁时可以再次得到该对象的锁。也就是说，当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁,请求就会成功，否则阻塞。一个简单的例子就是：在一个Synchronized修饰的方法或代码块的内部调用本类的其他Synchronized修饰的方法或代码块时，是永远可以得到锁的，示例代码A如下：1234567891011121314151617181920212223242526public class SyncDubbo &#123; public synchronized void method1() &#123; System.out.println("method1-----"); method2(); &#125; public synchronized void method2() &#123; System.out.println("method2-----"); method3(); &#125; public synchronized void method3() &#123; System.out.println("method3-----"); &#125; public static void main(String[] args) &#123; final SyncDubbo syncDubbo = new SyncDubbo(); new Thread(new Runnable() &#123; @Override public void run() &#123; syncDubbo.method1(); &#125; &#125;).start(); &#125;&#125;执行结果为：123method1-----method2-----method3-----示例代码A向我们演示了，如何在一个已经被synchronized关键字修饰过的方法再去调用对象中其他被synchronized修饰的方法。为什么要引入可重入锁这种机制？上一篇文章中介绍了“一个对象一把锁，多个对象多把锁”，可重入锁的概念就是：自己可以获取自己的内部锁。假如有1个线程T获得了对象A的锁，那么该线程T如果在未释放前再次请求该对象的锁时，如果没有可重入锁的机制，是不会获取到锁的，这样的话就会出现死锁的情况。就如代码A体现的那样，线程T在执行到method1()内部的时候，由于该线程已经获取了该对象syncDubbo 的对象锁，当执行到调用method2() 的时候，会再次请求该对象的对象锁，如果没有可重入锁机制的话，由于该线程T还未释放在刚进入method1() 时获取的对象锁，当执行到调用method2() 的时候，就会出现死锁。可重入锁到底有什么用？正如代码A和上面问题中所解释的那样，最大的作用是避免死锁。假如有一个场景：用户名和密码保存在本地txt文件中，则登录验证方法和更新密码方法都应该被加synchronized，那么当更新密码的时候需要验证密码的合法性，所以需要调用验证方法，此时是可以调用的。可重入锁的其他特性：父子可继承性可重入锁支持在父子类继承的环境中，示例代码如下：1234567891011121314151617181920212223242526272829303132333435363738public class SyncDubbo &#123; static class Main &#123; public int i = 5; public synchronized void operationSup() &#123; i--; System.out.println("Main print i =" + i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class Sub extends Main &#123; public synchronized void operationSub() &#123; while (i &gt; 0) &#123; i--; System.out.println("Sub print i = " + i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; public void run() &#123; Sub sub = new Sub(); sub.operationSub(); &#125; &#125;).start(); &#125;&#125;Synchronized的其他特性出现异常时锁自动释放就是说，当一个线程执行的代码出现异常的时候，其所持有的锁会自动释放，示例如下：1234567891011121314151617181920212223public class SyncException &#123; private int i = 0; public synchronized void operation() &#123; while (true) &#123; i++; System.out.println(Thread.currentThread().getName() + " , i= " + i); if (i == 10) &#123; Integer.parseInt("a"); &#125; &#125; &#125; public static void main(String[] args) &#123; final SyncException se = new SyncException(); new Thread(new Runnable() &#123; public void run() &#123; se.operation(); &#125; &#125;, "t1").start(); &#125;&#125;执行结果如下：123456789101112t1 , i= 2t1 , i= 3t1 , i= 4t1 , i= 5t1 , i= 6t1 , i= 7t1 , i= 8t1 , i= 9t1 , i= 10java.lang.NumberFormatException: For input string: "a" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) //其他输出信息可以看出，当执行代码报错的时候，程序不会再执行，即释放了锁。将任意对象作为监听器Java还支持对“任意对象”作为“对象监视器”来实现同步的功能。这个“任意对象”大多数是实例变量及方法的参数，使用synchronized(非this对象)synchronized(非this对象)格式的作用只有1中：synchronized(非this对象x)同步代码块在多个线程持有“对象监视器”为同一个对象的前提下，同一时间只有一个线程可以执行synchronized(非this对象x)同步代码块中的代码;当持有“对象监视器”为同一个对象的前提下，同一时间只有一个线程可以执行synchronized(非this对象x)同步代码块中的代码。示例如下：12345678910111213141516171819202122232425262728293031public class StringLock &#123; private String lock = "lock"; public void method() &#123; synchronized (lock) &#123; try &#123; System.out.println("当前线程： " + Thread.currentThread().getName() + "开始"); Thread.sleep(1000); System.out.println("当前线程： " + Thread.currentThread().getName() + "结束"); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; public static void main(String[] args) &#123; final StringLock stringLock = new StringLock(); new Thread(new Runnable() &#123; public void run() &#123; stringLock.method(); &#125; &#125;, "t1").start(); new Thread(new Runnable() &#123; public void run() &#123; stringLock.method(); &#125; &#125;, "t2").start(); &#125;&#125;执行结果：1234当前线程： t1开始当前线程： t1结束当前线程： t2开始当前线程： t2结束单例模式-双重校验锁普通的加锁的单例模式：12345678910111213141516public class Singleton &#123; private static Singleton instance = null; //懒汉模式 //private static Singleton instance = new Singleton(); //饿汉模式 private Singleton() &#123; &#125; public static synchronized Singleton newInstance() &#123; if (null == instance) &#123; //判断实例是否已经被其他线程创建了 instance = new Singleton(); &#125; return instance; &#125;&#125;使用上述的方式可以实现多线程的情况下获取到正确的实例对象，但是每次访问newInstance（）方法都会进行加锁和解锁操作，也就是说该锁可能会成为系统的瓶颈，为了解决这个问题，有人提出了“双重校验锁”的方式，示例代码如下：123456789101112131415161718192021222324public class DubbleSingleton &#123; private static DubbleSingleton instance; public static DubbleSingleton getInstance()&#123; if(instance == null)&#123; //判断实例是否已经被其他线程创建了，如果没有则创建 try &#123; //模拟初始化对象的准备时间... Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //类上加锁，表示当前对象不可以在其他线程的时候创建 synchronized (DubbleSingleton.class) &#123; //如果不加这一层判断的话，这样的话每一个线程会得到一个实例 //而不是所有的线程的到的是一个实例 if(instance == null)&#123; //从第一次判断是否为null到加锁之间的时间内判断实例是否已经被创建 instance = new DubbleSingleton(); &#125; &#125; &#125; return instance; &#125;&#125;那么问题来了，为什么volatile关键字可以实现禁止指令的重排序优化 以及什么是指令重排序优化哪？在Java内存模型中我们都是围绕着原子性、有序性和可见性进行讨论的。为了确保线程间的原子性、有序性和可见性，Java中使用了一些特殊的关键字申明或者是特殊的操作来告诉虚拟机，在这个地方，要注意一下，不能随意变动优化目标指令。关键字volatile就是其中之一。指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度（比如：将多条指定并行执行或者是调整指令的执行顺序）。编译器、处理器也遵循这样一个目标。注意是单线程。可显而知，多线程的情况下指令重排序就会给程序员带来问题。最重要的一个问题就是程序执行的顺序可能会被调整，另一个问题是对修改的属性无法及时的通知其他线程，已达到所有线程操作该属性的可见性。根据编译器的优化规则，如果不使用volatile关键字对变量进行修饰的，那么这个变量被修改后，其他线程可能并不会被通知到，甚至在别的想爱你城中，看到变量修改顺序都会是反的。一旦使用volatile关键字进行修饰的话，虚拟机就会特别小心的处理这种情况。参考文献徐刘根：Java多线程编程-（2）-可重入锁以及Synchronized的其他基本特性霓裳梦竹：synchronized将任意对象作为对象监视器]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>面试</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将IDEA的Springboot项目部署到Linux服务器]]></title>
    <url>%2Fp%2F2480269034%2F</url>
    <content type="text"><![CDATA[在前后端分离的情况下，如何单独将Springboot项目部署到服务器？以下是我的在第一次部署之后的记录和总结，希望可以帮到同样也刚刚用到服务器的你。部署服务器主要的几个步骤:1.服务器环境配置；2.配置项目并打包；3.部署到服务器；4.后台运行项目。服务器环境配置服务器环境：Debian8 x64(vps)本机环境：Mac，Intellij IDEA，FinalShell我们需要一个SSH工具来连接到服务器，因为我使用的MacOs，所以使用了FinalShell。如果安装了brew，可以通过brew cask install finalshell来安装FinalShell。Win用户可以使用Putty等软件。此处假设你已会简单使用SSH，并已经连上了你的服务器。Linux安装并配置JDK准备以root身份登录，因为我的vps默认就是root，所以我不用登录，如果需要的话，你可以输入su回车，然后再输入你的密码（linux输入密码不显示星号或其他替换符号），再回车即可。确认你的系统是否自带jdk，可以通过输入：1apt-get list installed | grep java来列举匹配已安装的java。如果没有，则继续；如果有，可以试试：1apt-get -y remove java-1.7.0-openjdk*来卸载（因为我没有试过）。接下来，我们新建一个目录来存放jdk。1mkdir /home/java进入该目录。1cd /home/java接下来的操作都是基于此路径进行，如果是存放在其他路径下，请注意对应修改。下载压缩包先到官网上查看需要的jdk版本，获取压缩包的下载链接，再使用命令下载这里选用jdk8，在本地点击打开下载主页，选中Accept License Agreement，点击Linux版本的的.tar.gz文件(x64或x86视你的Linux而定，可通过uname -a命令查看，有64即可下x64版本），复制对应的下载链接，这里不需要下载，只是为了获取下载链接。输入命令：1curl -O https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz?AuthParam=1554125860_f7bf6ea27a443245f5d1cb9fde89b37d注意O是大写的字母。-O 后面跟着刚才复制的下载链接，这个貌似要实时获取的链接才能下载，有AuthParam参数来校验，否则你会看到所有项都是 0 ，不会变化；出现这个情况的话，重新去点击那个文件，获取下载链接复制过来再试。用ls命令查看，可以看到当前目录下出现了一个jdk-8xxx.tar.gz文件（后缀的AuthParam=…不用管）。解压并安装使用命令解压（输入文件名可以输入前一部分，然后按tab键自动补全）1tar -zxvf jdk-8u201-linux-x64.tar.gz...此时使用ls命令可以看到路径下多处了一个目录jdk1.8.0_201。检查下载下来的jdk是否正常，输入以下命令验证：12/home/java/jdk1.8.0_201/bin/java -version/home/java/jdk1.8.0_201/bin/javac -version如果能够正常显示jdk的版本信息，即为正常；否则，重新下载。设置环境变量打开/ect/profile文件，并在文件末尾添加（JAVA_HOME的值根据实际路径填写）：12345# set java environmentexport JAVA_HOME=/home/java/jdk1.8.0_201export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH你可以通过以下两种方式使配置生效：重启机器：reboot;使用source命令：source /etc/profile、source ~/.bashrc分别输入命令 java -version和javac -version，若显示jdk的版本信息，说明已正确配置。可能出现的问题如果出现了-bash: java: command not found，检查上面的各个步骤，然后出现这个情况的，请仔细检查配置文件！以及/etc/profile的各项值是否设置正确。如果出现了-bash: ./java: cannot execute binary file，出现这个错误的原因可能是在32位的操作系统上安装了64位的jdk，检查jdk版本和Linux版本位数是否一致。安装Mysql|MariaDBMariaDB 和 MySQL是一家。MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。这里 安装 MariaDB 来用用，使用ssh工具连接登录上Linux。安装MariaDB1apt-get -y install mariadb-server安装时会让你设置数据库root用户的密码，这个密码和LInux的root用户密码是不同的。（2019.7.10：因为某些原因换了服务器，在Debian9例安装MariaDB直接跳过了密码设置，这样接下去需要输入密码的时候直接回车）Debain上MariaDB好像是自动启动的。手动启动1systemctl start mariadb.service手动设置服务自启动1systemctl enable mariadb.service配置和简单使用通过命令：1mysql -u root -p进入，然后输入你设置的密码。修改数据库字符集，使支持中文。先要查看数据库的原字符集设定可登录mysql后，1MariaDB [(none)]&gt; show variables like 'char%';可以看到：1234567891011121314MariaDB [(none)]&gt; show variables like 'char%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec)默认character_set_database项不为utf8，可以通过修改/etc/mysql/my.cnf配置文件更改。在该文件的mysqld字段内加上一句character-set-server=utf8。因为我使用systemctl restart mariadb重启mariadb服务无效，所以只能通过reboot来使配置生效。允许远程登陆登陆mysql12345678# mysql -uroot -p /*输入密码进入*//*第一个方式：直接编辑数据库字段*/MariaDB [(none)]&gt; use mysql;MariaDB [mysql]&gt; UPDATE user SET password=123456 WHERE user='root';/*修改允许远程访问*/GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;MariaDB [mysql]&gt; flush privileges;MariaDB [mysql]&gt; exit第一个位置,为数据库, 第二个位置,为表,所以 *.*,表示可以访问任意数据的任意表&#39;root&#39;@&#39;%&#39;, root表示远端登录使用的用户名,%表示允许任意ip登录,可将指定ip替换掉%, root与%可以自定义IDENTIFIED BY &#39;root&#39; 这个root 是登录时的使用的密码,(方便记忆就用了root,生产环境一定要替换掉)修改配置文件将/etc/mysql/mariadb.conf.d/50-server.cnf中bind-address = 127.0.0.1加# 注释掉重启服务1systemctl restart mariadb.service将本地Springboot项目打包确保你的项目完整，然后在右侧（或者边栏的其他地方）的Maven Projects中选中package双击或者右键点击Run Maven Build，然后你会看到在运行框程序正在打包。打包默认是你最初建项目时选中的jar工程。当运行框出现BUILD SUCCESS说明你的项目已经打包成功了，打包好的jar包是在项目的target文件夹下。将本地数据库上传至服务器我本地使用的是Mysql+Navicat Premium，如果你也是用的这个组合，那么接下来的操作会很简单。如果你没安装Navicat Premium，可以看Navicat Premium for Mac破解教程。如果是其他情况，我的文章里没有记录，请自行百度。下面是具体步骤：打开Navicat Premium，连接到你的服务器的数据库（请注意打开服务器的3306端口）；在服务器MySQL创建一个和 要迁移数据的数据库 同名的数据库，为了方便，直接在Navicat图形界面操作（有兴趣可以在命令行操作），右键 服务器连接 -&gt; 创建数据库 -&gt; 输入要迁移的数据库名，字符集选择utf8 – UTF-8 Unicode -&gt; 确定；进行数据迁移，点击Navicat菜单栏“工具” -&gt; 数据传输… -&gt; 设置“源”为本地数据库“localhost”，设置“目标”为服务器数据库，选择要传输的数据库，和接收数据的数据库 -&gt; 开始传输 -&gt; 确定 -&gt; 传输中… -&gt; 关闭（这是已经传好了，别点“开始”，不然又传一次）。部署到服务器并运行部署Springboot项目的话就不用下载tomcat了，Springboot内嵌tomcat。如果是之后还要部署其他项目，也可提前把tomcat下了。如果你配置了安全组或者防火墙，请打开必要的端口将生成的jar文件上传至你的服务器（可以任意位置），比如我上传至了/home下。cd到jar文件路径下，然后使用命令：12nohup java -jar demo-0.0.1-SNAPSHOT.jar &gt;/home/test.log&gt;&amp;1&amp;nohup java -jar 项目名称.jar &gt;/路径名称/输出的日志名称.log&gt;&amp;1&amp;然后可以直接在对应的端口/接口访问，也可以使用命令进行查看项目是否已经后台运行。可以使用：1ps -ef查看进程运行的情况。1234root 16974 5043 0 08:55 ? 00:00:00 bash -c export LANG="en_US.UTF-8";export LANGUroot 16979 16974 0 08:55 ? 00:00:00 sleep 1root 16980 5049 0 08:55 pts/0 00:00:00 ps -efroot 23904 1 0 04:23 ? 00:00:38 java -jar demo-0.0.1-SNAPSHOT.jar可以看到项目的进程号23904正在运行。如果需要停止项目的运行直接使用命令：kill 23904(进程号)测试端口推荐使用Postman进行端口的测试。参考文献markix：【入门篇】篇一、Linux服务器安装Java运行环境，即安装JDKmarkix：【入门篇】篇三、Linux服务器安装MySQL | MariaDBmarkix：【入门篇】篇四、将本地Web项目部署到服务器，迁移本地数据库到服务器Box_clf：如何将IDEA的Springboot项目打包到服务器进行后台运行]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>IntellijIDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-1-线程安全与锁]]></title>
    <url>%2Fp%2F739861978%2F</url>
    <content type="text"><![CDATA[进程与线程概念回顾进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。线程（Thread）有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。进程与线程的关系一个进程对于1或多道线程。Java实现多线程的方法继承Thread，重写run()方法1234567891011121314public class MyThread extends Thread &#123; @Override public void run() &#123; while (true) &#123; System.out.println(currentThread().getName()); &#125; &#125; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); //线程启动的正确方式 &#125;&#125;输出结果：1234Thread-0Thread-0Thread-0...要明白，启动线程的是start()方法而不是run()方法，如果用run()方法，那么它就是一个普通的方法被执行了。实现Runnable接口12345678910111213public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("123"); &#125; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable, "t1"); thread.start(); &#125;&#125;线程安全当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。这里的加锁机制常见的如：synchronized。锁的原理Java中每个对象都有一个内置锁。当程序运行到非静态的synchronized同步方法上时，自动获取与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。当程序运行到synchronized同步方法或代码块时，该对象锁才起作用。一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。释放锁是指持锁线程退出了synchronized同步方法或代码块。锁和同步关于锁和同步，有以下几个要点：只能同步方法，而不能同步变量和类；每个对象只有一个锁；当提到同步时，应当清楚在什么上同步？也就是说，在哪个对象上同步。不必同步类中所有的方法，类可以拥有同步和非同步的方法；如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，知道锁被释放。也就是说，如果一盒线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类的任何一个同步方法。线程睡眠时，它所持有的任何人锁都不会被释放；线程可以获得多个锁。比如，在一个对象的同步方法里面调用另一个对象的同步方法，则获得了两个对象的同步锁；同步损害并发性，应该尽可能的缩小同步范围。线程如果不能获取锁会怎么样如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可运行或运行为止。当考虑阻塞时，一定要注意哪个对象正被用于锁定：调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。synchronized修饰符可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。当我们不使用synchronized时123456789101112131415161718192021222324public class MyThread extends Thread &#123; private int count = 5; @Override public void run() &#123; count--; System.out.println(currentThread().getName() + " count:" + count); &#125; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread thread1 = new Thread(myThread, "thread1"); Thread thread2 = new Thread(myThread, "thread2"); Thread thread3 = new Thread(myThread, "thread3"); Thread thread4 = new Thread(myThread, "thread4"); Thread thread5 = new Thread(myThread, "thread5"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); thread5.start(); &#125;&#125;输出的一种结果为：12345thread1 count:3thread4 count:1thread2 count:3thread3 count:2thread5 count:0可以看到，上述的结果是不正确的，这是因为，多个线程同时操作run()方法，对count进行修改，进而造成错误。使用synchronized之后123456789101112131415161718192021222324public class MyThread extends Thread &#123; private int count = 5; @Override public synchronized void run() &#123; count--; System.out.println(currentThread().getName() + " count:" + count); &#125; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread thread1 = new Thread(myThread, "thread1"); Thread thread2 = new Thread(myThread, "thread2"); Thread thread3 = new Thread(myThread, "thread3"); Thread thread4 = new Thread(myThread, "thread4"); Thread thread5 = new Thread(myThread, "thread5"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); thread5.start(); &#125;&#125;输出的一种结果为：12345thread1 count:4thread3 count:3thread2 count:2thread4 count:1thread5 count:0可以看出代码A和代码B的区别就是在run()方法上加上了synchronized修饰.说明当多个线程访问MyThread 的run()方法的时候，如果使用了synchronized修饰，那个多线程就会以排队的方式进行处理（这里排队是按照CPU分配的先后顺序而定的）。一个线程想要执行synchronized修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行synchronized代码体的内容，如果拿不到锁的话，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且多个线程同时去竞争这把锁，也就是会出现锁竞争的问题。使用synchronized同步不但可以同步整个方法，还可以同步方法中的一部分代码块；在使用同步代码块的时候，**应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：123456public int fix(int y)&#123; synchronized (this) &#123; x = x - y; &#125; return x;&#125;当然，同步方法也可以改写成非同步方法，但功能完全一样的，例如：123public synchronized int getX() &#123; return x++;&#125;与12345public int getX() &#123; synchronized (this) &#123; return x++; &#125;&#125;效果完全一样。一个对象有一把锁，多个线程有多把锁首先我们来看一下下面的代码实例：1234567891011121314151617181920212223242526272829303132public class MultiThread &#123; private int num = 200; public synchronized void printNum(String threadName, String tag) &#123; if (tag.equals("a")) &#123; num = num - 100; System.out.println(threadName + " tag a,set num over!"); &#125; else &#123; num = num - 200; System.out.println(threadName + " tag b,set num over!"); &#125; System.out.println(threadName + " tag " + tag + ", num = " + num); &#125; public static void main(String[] args) throws InterruptedException &#123; final MultiThread multiThread1 = new MultiThread(); final MultiThread multiThread2 = new MultiThread(); new Thread(new Runnable() &#123; public void run() &#123; multiThread1.printNum("thread1", "a"); &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; multiThread2.printNum("thread2", "b"); &#125; &#125;).start(); &#125;&#125;输出结果：1234thread1 tag a,set num over!thread1 tag a, num = 100thread2 tag b,set num over!thread2 tag b, num = 0可以看出，有两个对象：multiThread1和multiThread2，如果多个对象使用同一把锁的话，那么上述执行的结果就应该是：thread2 tag b, num = -100，因此，是每一个对象拥有该对象的锁的。关键字synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁，所以上述实例代码中哪个线程先执行synchronized 关键字的方法，那个线程就持有该方法所属对象的锁，两个对象，线程获得的就是两个不同对象的不同的锁，他们互不影响的。那么，我们在正常的场景的时候，肯定是有一种情况的就是，所有的对象会对一个变量count进行操作，那么如何实现哪？很简单就是加static，我们知道，用static修改的方法或者变量，在该类的所有对象是具有相同的引用的，这样的话，无论实例化多少对象，调用的都是一个方法，代码如下：1234567891011121314151617181920212223242526272829303132333435public class MultiThread &#123; private static int num = 200; public static synchronized void printNum(String threadName, String tag) &#123; if (tag.equals("a")) &#123; num = num - 100; System.out.println(threadName + " tag a,set num over!"); &#125; else &#123; num = num - 200; System.out.println(threadName + " tag b,set num over!"); &#125; System.out.println(threadName + " tag " + tag + ", num = " + num); &#125; public static void main(String[] args) throws InterruptedException &#123; final MultiThread multiThread1 = new MultiThread(); final MultiThread multiThread2 = new MultiThread(); new Thread(new Runnable() &#123; public void run() &#123; multiThread1.printNum("thread1", "a"); &#125; &#125;).start(); Thread.sleep(5000); System.out.println("等待5秒，确保thread1已经执行完毕！"); new Thread(new Runnable() &#123; public void run() &#123; multiThread2.printNum("thread2", "b"); &#125; &#125;).start(); &#125;&#125;输出结果如下：12345thread1 tag a,set num over!thread1 tag a, num = 100等待5秒，确保thread1已经执行完毕！thread2 tag b,set num over!thread2 tag b, num = -100可以看出，对变量和方法都加上了static修饰，就可以实现我们所需要的场景，同时也说明了，对于非静态static修饰的方法或变量，是一个对象一把锁的。对象锁的同步和异步同步：synchronized同步的概念就是”共享”，我们要知道“共享”这两个字，如果不是共享的资源，就没有必要进行同步，也就是没有必要进行加锁；同步的目的就是为了线程的安全，其实对于线程的安全，需要满足两个最基本的特性：原子性和可见性。原子性指线程已经是最小单位，不可再拆封；可见性是指一个线程对共享变量值的修改，能够及时的被其他线程看到（详见链接3）。异步：asynchronized异步的概念就是独立，相互之间不受到任何制约，两者之间没有任何关系。示例：12345678910111213141516171819202122232425public class MyObject &#123; public void method() &#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject myObject = new MyObject(); Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; myObject.method(); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; myObject.method(); &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125;上述代码中，method()方法就是异步的。何时需要同步在多个线程同时访问互斥（可交换）数据时，应该同步以加以保护数据，确保两个线程不会同时秀给更改它。对于非静态字段中可更改的数据，通常使用非静态的方法访问。对于静态字段中可更改的数据，通常使用静态方法访问。如果需要在非静态方法中使用静态字段，或者在静态字段中调用非静态方法，问题将变得非常复杂。小结线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。对于同步，要时刻清醒在哪个对象上同步，这是关键。编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定能写出来，但是，一旦程序发生死锁，程序将死掉。参考文献Ruthless：Java多线程-线程的同步与锁徐刘根：Java多线程编程-（1）-线程安全和锁Synchronized概念长风破浪会有33：线程间的可见性]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>面试</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Map类之HashMap实现原理及源码分析]]></title>
    <url>%2Fp%2F4288673006%2F</url>
    <content type="text"><![CDATA[哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。什么是哈希表在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。存储位置 = f(关键字)其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。哈希冲突然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式。JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。HashMap实现原理HashMap的主干是一个Node数组（在旧版本的代码中为Entry）。Node是HashMap的基本组成单元，每一个Node包含一个key-value键值对。12//HashMap的主干数组，可以看到就是一个Node数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。transient Node&lt;K,V&gt;[] table = (Node&lt;K,V&gt;[]) EMPTY_TABLEEntry是HashMap中的一个静态内部类。代码如下:12345678910111213141516static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算 final K key; V value; Node&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ... &#125;所以，HashMap的整体结构如下：简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。其他几个重要字段：12345678//实际存储的key-value键值对的个数transient int size;//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到int threshold;//负载因子，代表了table的填充度有多少，默认是0.75final float loadFactor;//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationExceptiontransient int modCount;HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值initialCapacity默认为16，loadFactory默认为0.75。在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组。接下来是put操作的实现：以下均为旧版本jdk中HashMap的源码123456789101112131415161718192021222324public V put(K key, V value) &#123; //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; //如果key为null，存储位置为table[0]或table[0]的冲突链上 if (key == null) return putForNullKey(value); int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀 int i = indexFor(hash, table.length);//获取在table中的实际位置 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败 addEntry(hash, key, value, i);//新增一个entry return null;&#125;先来看看inflateTable这个方法123456private void inflateTable(int toSize) &#123; int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂 threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 table = new Entry[capacity]; initHashSeedAsNeeded(capacity); &#125;inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.123456private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : "number must be non-negative"; return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1; &#125;roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.hash函数123456789101112//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125;以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置123456 /** * 返回数组下标 */static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125;h&amp;(length-1)保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为1234 1 0 0 1 0&amp; 0 1 1 1 1__________________ 0 0 0 1 0 = 2最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）所以最终存储位置的确定流程是这样的：再来看看addEntry的实现：123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125;通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。重写equals方法需同时重写hashCode方法关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题。1234567891011121314151617181920212223242526272829303132333435/** * Created by chengxiao on 2016/11/15. */public class MyTest &#123; private static class Person&#123; int idCard; String name; public Person(int idCard, String name) &#123; this.idCard = idCard; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass())&#123; return false; &#125; Person person = (Person) o; //两个对象是否等值，通过idCard来确定 return this.idCard == person.idCard; &#125; &#125; public static void main(String []args)&#123; HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;(); Person person = new Person(1234,"乔峰"); //put到hashmap中去 map.put(person,"天龙八部"); //get取出，从逻辑上讲应该能输出“天龙八部” System.out.println("结果:"+map.get(new Person(1234,"萧峰"))); &#125;&#125;实际输出结果：1结果：null如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置 ，而通过key取出value的时候key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。Java1.8-IdentityHashMap源码解析概述IdentityHashMap利用Hash表来实现Map接口，比较键（和值）时使用引用相等性代替对象相等性，也就是说使用 == 而不是使用 equals。ConcurrentHashMapConcurrentHashMap比Hashtable效率更高。HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。底层采用分段的数组+链表实现，线程安全通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容参考文献dreamcatcher-cx：HashMap实现原理及源码分析阿善9：面试题:Concurrenthashmap原理分析 有用夏雪冬日：面试必备：HashMap、Hashtable、ConcurrentHashMap的原理与区别]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>集合</tag>
        <tag>面试</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合类介绍]]></title>
    <url>%2Fp%2F337471241%2F</url>
    <content type="text"><![CDATA[通常，我们的程序需要根据程序运行时才知道创建多少个对象。但若非程序运行，程序开发阶段，我们根本不知道到底需要多少个数量的对象，甚至不知道它的准确类型。为了满足这些常规的编程需要，我们要求能在任何时候，任何地点创建任意数量的对象，而这些对象用什么来容纳呢？我们首先想到了数组，但是数组只能放统一类型的数据，而且其长度是固定的，那怎么办呢？集合便应运而生了。Java数组的基本操作ArrayList和LinkedList各自实现和区别Java Map类之HashMap实现原理及源码分析Java集合类详细介绍集合与数组数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。Java集合类存放于 java.util 包中，是一个用来存放对象的容器。集合只能存放对象。比如你存一个 int 型数据 1放入集合中，其实它是自动转换成 Integer 类后存入的，Java中每一种基本类型都有对应的引用类型。集合存放的是多个对象的引用，对象本身还是放在堆内存中。集合可以存放不同类型，不限数量的数据类型。集合中的接口和类的关系Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。Iterator所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：1.hasNext()是否还有下一个元素。2.next()返回下一个元素。3.remove()删除当前元素。因为是接口，我们不能直接new对象，所以我们主要使用的是他们的实现类。Q1.有序和无序指什么？有序即你从List中取出元素的顺序和你存入的顺序相对应；无序即Set中取数据的顺序和存入的顺序没有对应关系。Q2.Map的一个key可以存多个value吗？网上有使用IdentityHashMap”实现”一个key中保存多个value。下面是那段代码的例子：123456789101112131415161718192021222324252627import java.util.IdentityHashMap;import java.util.Map;import java.util.Map.Entry; public class MapTest &#123; public static void main(String[] args) &#123; String str1 = new String("xx"); String str2 = new String("xx"); System.out.println(str1 == str2); Map&lt;String,String&gt; map = new IdentityHashMap&lt;String,String&gt;(); map.put(str1, "hello"); map.put(str2, "world"); // 遍历map for(Entry&lt;String,String&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey()+" " + entry.getValue()); &#125; System.out.println(" containsKey---&gt; " + map.containsKey("xx")); System.out.println("str1 containsKey---&gt; " + map.containsKey(str1)); System.out.println("str2 containsKey---&gt; " + map.containsKey(str2)); System.out.println(" value----&gt; " + map.get("xx")); System.out.println("str1 value----&gt; " + map.get(str1)); System.out.println("str2 value----&gt; " + map.get(str2)); &#125;&#125;输出的结果为：123456789falsexx worldxx hello containsKey---&gt; falsestr1 containsKey---&gt; truestr2 containsKey---&gt; true value----&gt; nullstr1 value----&gt; hellostr2 value----&gt; world从输出结果可以看出，xx能够同时对应两个value不是因为一个key保存了多个值，而是因为srt1和str2通过new产生了不同的地址，相当于是两个不同的key。关于IdentityHashMap可以看一下Java Map类之HashMap实现原理及源码分析里对应的部分。apache commons工具包里有个org.apache.commons.collections.map.MultiValueMap，可以更好的完成这个功能。123456789101112131415161718192021222324import org.apache.commons.collections.map.MultiValueMap;import java.util.Collection; public class TestMain&#123; public static void main(String[] args) throws IOException &#123; MultiValueMap mailMap = new MultiValueMap(); mailMap.put("number", "1"); mailMap.put("number", "30"); mailMap.put("name", "wang"); mailMap.put("card", "12344"); mailMap.put("card", "65432"); Collection mapcoll = null; mapcoll = mailMap.getCollection("card"); Iterator ii = mapcoll.iterator(); while(ii.hasNext())&#123; String mailValue = (String) ii.next(); System.out.println(mailValue); &#125; &#125; &#125;因为我没下这个工作包，没有运行过这段代码，应该是能实现的在网上，我也找到了一个博主自己写的MultiValueMap，实现了一个key存多个值。有兴趣的可以戳详情：Map之一个Key存多个Value的MultiValueMap(一个键多个值)常用集合类介绍常用的List、Map、Set三个接口，存取元素时，有以下特点：List ：以特定顺序来持有元素，可以有重复元素。Set ：不能有重复元素,内部排序。Map ：保存key-value值，value可多值。接口子接口是否有序是否允许元素重复Collection否ListArrayList否是LinkedList否是Vector否是SetAbstractSet否否HashSet否否TreeSet是（用二叉排序树）否MapAbstractMap否使用key-value来映射和存储数据，key必须唯一，value可以重复HashMap否同TreeMap是（用二叉排序树）同list, set,map对比层次图ListList里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。ArrayListArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组.在初始化ArrayList时，会构建空数组（Object[] elementData={}）。ArrayList是无序的，它是按照添加的先后顺序排列，当然，它也提供了sort方法，如果需要对ArrayList进行排序，只需要调用这个方法，提供 Comparator比较器即可.LinkedListLinkedList是基于链表的，它是一个双向链表，每个节点维护了一个prev和next指针。同时对于这个链表，维护了first和last指针，first指向第一个元素，last指向最后一个元素。LinkedList是一个无序的链表，按照插入的先后顺序排序，不提供sort方法对内部元素排序。因为是链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义.遍历在类集中提供了以下四种的常见输出方式：Iterator：迭代输出，是使用最多的输出方式。ListIterator：是Iterator的子接口，专门用于输出List中的内容。foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。for循环代码示例如下：1234567//for的形式：for（int i=0;i&lt;arr.size();i++）&#123;...&#125;//foreach的形式： for（int i：arr）&#123;...&#125;//iterator的形式：Iterator it = arr.iterator();while(it.hasNext())&#123; object o =it.next(); ...&#125;Q1.迭代、遍历、循环、迭代的区别表示“重复”这个含义的词有很多, 比如循环(loop), 递归(recursion), 遍历(traversal), 迭代(iterate).循环算是最基础的概念, 凡是重复执行一段代码, 都可以称之为循环。大部分的递归, 遍历, 迭代, 都是循环.递归是重复调用函数自身实现循环，将简单情况逐步转化为基本情况。迭代是函数内某段代码实现循环，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。VectorVector 和ArrayList类似,但属于强同步类（？）。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。效率太低，正在被淘汰。SetSet里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。HashSetHashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，而HashMap的value始终都是PRESENT。HashSet不允许重复（HashMap的key不允许重复，如果出现重复就覆盖），允许null值，非线程安全。TreeSet基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator进行排序，具体取决于使用的构造方法。遍历对它的遍历和List类似。迭代遍历123456Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; String str = it.next(); System.out.println(str); &#125;for(each)循环遍历123for (String str : set) &#123; System.out.println(str); &#125;MapMap集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。HashMap数组方式存储key/value，线程非安全，允许null作为key和value，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，key的hash值是先计算key的hashcode值，然后再进行计算，每次容量扩容会重新计算所以key的hash值，会消耗资源，要求key必须重写equals和hashcode方法。默认初始容量16，加载因子0.75，扩容为旧容量乘2（扩容是一个十分耗时的操作），查找元素快。HashtableHashtable与HashMap类似，但它的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap这个区别就像Vector和ArrayList一样，因此也导致了Hashtale在写入时会比较慢。它继承自Dictionary类，不同的是Hashtable不允许 null 值(key 和 value 都不可以)，HashMap允许 null 值(key和value都可以)。LinkedHashMapLinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。TreeMap基于红黑二叉树的NavigableMap的实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出ClassCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出。遍历KeySet()将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。123456789101112Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4"); //先获取map集合的所有键的set集合，keyset（）Iterator it = map.keySet().iterator();//获取迭代器while(it.hasNext())&#123; Object key = it.next(); System.out.println(map.get(key));&#125;values()获取所有的值，Collection values()不能获取到key对象123456Collection&lt;String&gt; vs = map.values();Iterator&lt;String&gt; it = vs.iterator();while (it.hasNext()) &#123; String value = it.next(); System.out.println(" value=" + value);&#125;entrySet()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图(一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。(Map.Entry表示映射关系)entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。典型用法如下：123456789101112// 返回的Map.Entry对象的Set集合 Map.Entry包含了key和value对象Set&lt;Map.Entry&lt;Integer, String&gt;&gt; es = map.entrySet();Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = es.iterator();while (it.hasNext()) &#123; // 返回的是封装了key和value对象的Map.Entry对象 Map.Entry&lt;Integer, String&gt; en = it.next(); // 获取Map.Entry对象中封装的key和value对象 Integer key = en.getKey(); String value = en.getValue(); System.out.println("key=" + key + " value=" + value);&#125;推荐使用第三种方式，即entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。总结Vector和ArrayListvector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大（增加变化快）的数据，用vector有一定的优势。如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，因此如果频繁的访问数据，使用vector和arraylist都可以；而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linkedlist,因为它移动一个指定位置的数据时其它元素不移动。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢。Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差；LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。ArrayList和LinkedListArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。HashMap与TreeMapHashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false；而在TreeMap中，同样的值的map,顺序不同，equals时，true（说明：TreeMap在equals()时是整理了顺序了的）。HashTable与HashMap同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。HashMap允许存在一个为null的key，多个为null的value 。Hashtable的key和value都不允许为null。参考文献杨立果：java集合（list,set,map)技术特工队：java Map 一个key其实可以保存多个valueWarren技术宅：MultiValueMap的用法（一个key对应多个value）YSOcean：Java 集合详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>集合</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList和LinkedList各自实现和区别]]></title>
    <url>%2Fp%2F3958123573%2F</url>
    <content type="text"><![CDATA[同步性ArrayList,LinkedList是不同步的，而Vector是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。Q1.同步性是什么？为什么会对线程安全有影响？同步性是指多个线程访问同一个对象。比如一个线程在遍历时，另一个线程同时对其进行操作，可能因为多个线程同时操作而产生问题。Q2.线程安全是什么？线程安全是指多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。数据增长从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。Q1.ArrayList难道不能设置集合的初始大小来避免不必要的资源开销吗？可以。如果我们知道一个ArrayList将会有多少个元素，我们可以通过构造方法来指定容量。我们还可以通过trimToSize方法在ArrayList分配完毕之后去掉浪费掉的空间。Q2.LinkedList是以什么形式来存储的？它的扩展方式有什么不同？LinkedList定义了一个双向链表。当我们将一个元素加到LinkedList，只是简单的为这个元素分配一个记录，然后调整两个连接。效率一般大家都知道ArrayList和LinkedList的大致区别：ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。 这就是上面所说的移动数据。而在LinkedList中，因为采用了链表的形式，插入、删除集合中任何位置的元素所花费的时间都是一样的——O(1)；但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。下面比较ArrayList和LinkedList在性能上的差异。时间复杂度首先一点关键的是，ArrayList的内部实现是基于基础的对象数组的，因此，它使用get方法访问列表中的任意一个元素时 (random access)，它的速度要比LinkedList快。LinkedList中的get方法是按照顺序从列表的一端开始检查，直到另外一端。对 LinkedList而言，访问列表中的某个指定元素没有更快的方法了。假设我们有一个很大的列表，它里面的元素已经排好序了，这个列表可能是ArrayList类型的也可能是LinkedList类型的。现在我们对这个列表来进行二分查找(binary search)，比较列表是ArrayList和LinkedList的查询速度；对其进行大量的插入和删除操作，我们重复的在一个列表的开端插入一个元素（这是极端的例子），比较列表是ArrayList和LinkedList的添加速度。看下面的程序：123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.LinkedList; import java.util.List; import java.util.ArrayList; /**ArrayList 和 LinkedList 的时间复杂比较 * @author somelou * @date 2019-3-20 * */ public class ListTimeComparison &#123; static final int N=500000; static long timeList(List&lt;Object&gt; list)&#123; long start=System.currentTimeMillis(); var object = new Object(); for(int i=0;i&lt;N;i++) &#123; list.add(0, object); &#125; return System.currentTimeMillis()-start; &#125; static long readList(List&lt;Object&gt; list)&#123; long start=System.currentTimeMillis(); for(int i=0,j=list.size();i&lt;j;i++)&#123; list.get(i); &#125; return System.currentTimeMillis()-start; &#125; static List&lt;Object&gt; addList(List&lt;Object&gt; list)&#123; Object o = new Object(); for(int i=0;i&lt;N;i++) &#123; list.add(0, o); &#125; return list; &#125; public static void main(String[] args) &#123; System.out.println("ArrayList添加"+N+"条耗时："+timeList(new ArrayList&lt;Object&gt;())); System.out.println("LinkedList添加"+N+"条耗时："+timeList(new LinkedList&lt;Object&gt;())); List&lt;Object&gt; list1=addList(new ArrayList&lt;&gt;()); List&lt;Object&gt; list2=addList(new LinkedList&lt;&gt;()); System.out.println("ArrayList查找"+N+"条耗时："+readList(list1)); System.out.println("LinkedList查找"+N+"条耗时："+readList(list2)); &#125;&#125;当我们以500000条数据为例时，测试运行结果为：ArrayList和LinkedList查询和插入的结果这个结果不是固定的，但是基本上ArrayList的查找时间要明显小于LinkedList的时间。因此在这种情况下不宜用LinkedList。二分查找法使用的随机访问(random access)策略，而LinkedList是不支持快速的随机访问的。对一个LinkedList做随机访问所消耗的时间与这个list的大小是成比例 的。而相应的，在ArrayList中进行随机访问所消耗的时间是固定的。这是否表明ArrayList总是比LinkedList性能要好呢？这并不一定，在不断往列表开头添加元素的情况下，LinkedList的表现要优于ArrayList。有些算法在LinkedList中实现时效率更高，比方说，利用 Collections.reverse方法对列表进行反转时，其性能就要好些。当一个元素被加到ArrayList的最开端时，所有已经存在的元素都会后移，这就意味着数据移动和复制上的开销。相反的，将一个元素加到LinkedList的最开端只是简单的为这个元素分配一个记录，然后调整两个连接。在 LinkedList的开端增加一个元素的开销是固定的，而在ArrayList的开端增加一个元素的开销是与ArrayList的大小成比例的。空间复杂度在LinkedList中有一个私有类，定义如下：1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;每个Node对象 reference列表中的一个元素，同时还有在LinkedList中它的上一个元素和下一个元素。一个有1000个元素的LinkedList对象将有1000个链接在一起的Node对象，每个对象都对应于列表中的一个元素。这样的话，在一个LinkedList结构中将有一个很大的空间开销，因为它要存储这1000个Node对象的相关信息。ArrayList使用一个内置的数组来存储元素，这个数组的起始容量是10.当数组需要增长时，新的容量按如下公式获得：新容量=(旧容量*3)/2+1。也就是如前面所说，每一次容量大概会增长50%。这就意味着，如果你有一个包含大量元素的ArrayList对象， 那么最终将有很大的空间会被浪费掉，这个浪费是由ArrayList的工作方式本身造成的。如果没有足够的空间来存放新的元素，数组将不得不被重新进行分配以便能够增加新的元素。对数组进行重新分配，将会导致性能急剧下降。参考文献Alan·Jones：描述一下ArrayList和LinkedList各自实现和区别全力以赴001：Java中ArrayList和LinkedList区别]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>语法</tag>
        <tag>集合</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat Premium for Mac破解教程]]></title>
    <url>%2Fp%2F850238276%2F</url>
    <content type="text"><![CDATA[说明这份文件来自DoubleLabyrinth/navicat-keygen，对其中一些点进行补充说明Navicat Premium for Mac官方下载地址：中文版|英文版这份repo将会告诉你Navicat是怎么完成离线激活的：注册机是怎么工作的?破解软件是违法行为，但…如果…联系我会马上进行删除准备工作在编译之前，你应该确保你有如下几个库： 1234opensslcapstonekeystonerapidjson如果你有brew的话，你可以通过1234$ brew install openssl$ brew install capstone$ brew install keystone$ brew install rapidjson来完成它们的安装。Git项目Clone mac 分支，并编译keygen和patcher123$ git clone -b mac https://github.com/DoubleLabyrinth/navicat-keygen.git$ cd navicat-keygen$ make all编译完成后你会在 bin/ 文件夹下看到两个可执行文件：12$ ls bin/navicat-keygen navicat-patcher如何使用这个Keygen编译好keygen和patcher。备份好 Navicat Premium.app/Contents/MacOS/Navicat Premium 以及Navicat中所有已保存的数据库连接（包括密码）。移除所有Navicat在 Keychain.app （即钥匙链）中保存的连接，如果有的话。你可以通过搜索关键词 navicat 来找到它们。使用navicat-patcher替换掉公钥：12Usage: navicat-patcher &lt;navicat executable file&gt; [RSA-2048 PrivateKey(PEM file)]&lt;navicat executable file&gt;: Navicat可执行文件的路径。这个参数必须指定。[RSA-2048 PrivateKey(PEM file)]: RSA-2048私钥文件的路径。这个参数是可选的。 如果没有指定，navicat-patcher将会在当前目录下生成一个新的RSA-2048私钥文件RegPrivateKey.pem。例如：1$ ./navicat-patcher /Applications/Navicat\ Premium.app/Contents/MacOS/Navicat\ Premium在这里可能出现no such file or directory: ./navicat-patcher的错误cd到~/navicat-keygen/bin目录下即可，因为navicat-patcher在该目录下Navicat Premium For Mac 12.1.15 简体中文版 已通过测试。下面将是一份样例输出：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687**************************************************** Navicat Patcher by @DoubleLabyrinth ** Version: 3.0 ****************************************************Press Enter to continue or Ctrl + C to abort.PatchSolution0 ...... Ready to apply. Info: Keyword offset = +0x02d3c48cPatchSolution1 ...... Omitted.PatchSolution2 ...... Ready to apply. Info: Target function offset = +0x00f650a2 Info: Keyword offset = +0x02ed1bc8 Info: std::string::append(const char*) offset = +02613e44MESSAGE: Generating new RSA private key, it may take a long time.MESSAGE: New RSA private key has been saved to RegPrivateKey.pem.Your RSA public key:-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt1haNfmdWMA2V11CqGIB+vce/v0mulh5SNcpto6yaklyup6UO4ryVea9L2X8Tw2rh1xwcqJjD29a8MNaMB7B6FbLAdLleNjcWBUSfWeomOIrWHtGIfUUyMLrFAhAx0Vj5EjTZVv3F7r1HaCUEyq9wT3rC1XQs4YKzE9dL+sGXB+BuCg2l0eQPFojc+k48IbuMIUPqR63g9IfXtjqS6vt6rbeWk3nB0QEzOVPVrrRP6sZAZzovY21ZQ/5cw6WE3x03SGtjbsS65KaHfUljHGHIjQF0OhH7teS3AYGv7ydRUTRJ/nvT9JnWM7MQfJ8uq1Hc6JLW7sKhBNf/Ia6TkvzgwIDAQAB-----END PUBLIC KEY-----***************************** Begin PatchSolution0 *****************************@+0x02d3c48cPrevious:+0x0000000002d3c480 73 0a 25 73 0a 25 73 0a 25 73 0a 00 2d 2d 2d 2d s.%s.%s.%s..----+0x0000000002d3c490 2d 42 45 47 49 4e 20 50 55 42 4c 49 43 20 4b 45 -BEGIN PUBLIC KE+0x0000000002d3c4a0 59 2d 2d 2d 2d 2d 00 4d 49 49 42 49 6a 41 4e 42 Y-----.MIIBIjANB+0x0000000002d3c4b0 67 6b 71 68 6b 69 47 39 77 30 42 41 51 45 46 41 gkqhkiG9w0BAQEFA.........After:+0x0000000002d3c480 73 0a 25 73 0a 25 73 0a 25 73 0a 00 2d 2d 2d 2d s.%s.%s.%s..----+0x0000000002d3c490 2d 42 45 47 49 4e 20 50 55 42 4c 49 43 20 4b 45 -BEGIN PUBLIC KE+0x0000000002d3c4a0 59 2d 2d 2d 2d 2d 00 4d 49 49 42 49 6a 41 4e 42 Y-----.MIIBIjANB+0x0000000002d3c4b0 67 6b 71 68 6b 69 47 39 77 30 42 41 51 45 46 41 gkqhkiG9w0BAQEFA.........***************************** Begin PatchSolution2 *****************************@+0x02ed1bc8Previous:+0x0000000002ed1bc0 ee 00 00 00 17 00 00 00 42 49 6a 57 79 6f 65 52 ........BIjWyoeR+0x0000000002ed1bd0 52 30 4e 42 67 6b 71 6e 44 5a 57 78 43 67 4b 43 R0NBgkqnDZWxCgKC+0x0000000002ed1be0 45 41 77 31 64 71 46 33 44 54 76 4f 42 39 31 5a EAw1dqF3DTvOB91Z.........After:+0x0000000002ed1bc0 ee 00 00 00 17 00 00 00 4d 49 49 42 49 6a 41 4e ........MIIBIjAN+0x0000000002ed1bd0 42 67 6b 71 68 6b 69 47 39 77 30 42 41 51 45 46 BgkqhkiG9w0BAQEF+0x0000000002ed1be0 41 41 4f 43 41 51 38 41 4d 49 49 42 43 67 4b 43 AAOCAQ8AMIIBCgKC.........@+0x00f650a2Previous:+0x0000000000f650a0 0f 0b 55 48 89 e5 41 57 41 56 53 48 83 ec 48 c6 ..UH..AWAVSH..H.+0x0000000000f650b0 45 e5 01 31 c0 88 45 e6 48 89 fb 88 45 e7 0f 57 E..1..E.H...E..W+0x0000000000f650c0 c0 48 8d 7d a0 0f 29 07 48 c7 47 10 00 00 00 00 .H.&#125;..).H.G.....+0x0000000000f650d0 48 8d 35 ef 74 e0 01 e8 68 ed 6a 01 e8 19 e8 00 H.5.t...h.j.....+0x0000000000f650e0 00 88 45 e5 e8 77 e8 00 00 88 45 e6 e8 d5 e8 00 ..E..w....E.....+0x0000000000f650f0 00 88 45 e7 f6 45 e7 01 0f 85 35 0c 00 00 f6 45 ..E..E....5....EAfter:+0x0000000000f650a0 0f 0b 55 48 89 e5 41 57 41 56 53 48 83 ec 48 48 ..UH..AWAVSH..HH+0x0000000000f650b0 89 fb 48 31 c0 48 89 04 24 48 89 44 24 08 48 89 ..H1.H..$H.D$.H.+0x0000000000f650c0 44 24 10 48 8d 3c 24 48 8d 35 fa ca f6 01 e8 71 D$.H.&lt;$H.5.....q+0x0000000000f650d0 ed 6a 01 48 8b 04 24 48 89 03 48 8b 44 24 08 48 .j.H..$H..H.D$.H+0x0000000000f650e0 89 43 08 48 8b 44 24 10 48 89 43 10 48 89 d8 48 .C.H.D$.H.C.H..H+0x0000000000f650f0 83 c4 48 5b 41 5e 41 5f 5d c3 35 0c 00 00 f6 45 ..H[A^A_].5....EMESSAGE: PatchSolution0 has been applied.MESSAGE: PatchSolution2 has been applied.MESSAGE: Patch has been done successfully. Have fun and enjoy~仅对 Navicat Premium 版本 &lt; 12.0.24 的说明：如果你的Navicat版本小于12.0.24，那么navicat-patcher将会终止并且不会修改目标文件。你必须使用openssl生成RegPrivateKey.pem和rpk文件：12$ openssl genrsa -out RegPrivateKey.pem 2048$ openssl rsa -in RegPrivateKey.pem -pubout -out rpk接着用刚生成的rpk文件替换1/Applications/Navicat Premium.app/Contents/Resources/rpk生成代码证书生成一份自签名的代码证书，并总是信任该证书。这一步非常重要。此部分来自Silence-W的MacOS 下 Navicat Premium 12.1 版本破解生成自签名的代码签名证书，打开Keychain.app（钥匙串访问）设置证书 信任证书 重签名用codesign对Navicat Premium.app重签名。1$ codesign -f -s "Your self-signed code-sign certificate name" &lt;path to Navicat Premium.app&gt;注意：“Your self-signed code-sign certificate name”是你证书的名字，不是路径。例如：1$ codesign -f -s "foobar" /Applications/Navicat\ Premium.app/生成序列号接下来使用navicat-keygen来生成 序列号 和 激活码。12Usage: navicat-keygen &lt;RSA-2048 PrivateKey(PEM file)&gt;&lt;RSA-2048 PrivateKey(PEM file)&gt;: RSA-2048私钥文件的路径。这个参数必须指定。例如：1./navicat-keygen ./RegPrivateKey.pem你会被要求选择Navicat的语言以及输入主版本号。之后会随机生成一个 序列号。1234567891011121314151617181920Which is your Navicat Premium language?0. English1. Simplified Chinese2. Traditional Chinese3. Japanese4. Polish5. Spanish6. French7. German8. Korean9. Russian10. Portuguese(Input index)&gt; 1(Input major version number, range: 0 ~ 15, default: 12)&gt; 12Serial number:NAVK-MWQR-LNXV-886VYour name:你可以使用这个 序列号 暂时激活Navicat。生成激活码接下来你会被要求输入用户名和组织名；请随便填写，但不要太长。123Your name: DoubleLabyrinthYour organization: DoubleLabyrinthInput request code (in Base64), input empty line to end:之后你会被要求填入请求码。注意 不要关闭注册机.断开网络 并打开Navicat。找到注册窗口，填入注册机给你的序列号。然后点击激活按钮。一般来说在线激活肯定会失败，这时候Navicat会询问你是否手动激活，直接选吧。在手动激活窗口你会得到一个请求码，复制它并把它粘贴到keygen里。最后别忘了连按至少两下回车结束输入。1234567891011121314151617181920212223Your name: DoubleLabyrinthYour organization: DoubleLabyrinthInput request code (in Base64), input empty line to end:q/cv0bkTrG1YDkS+fajFdi85bwNVBD/lc5jBYJPOSS5bfl4DdtnfXo+RRxdMjJtEcYQnvLPi2LF0OB464brX9dqU29/O+A3qstSyhBq5//iezxfu2Maqca4y0rVtZgQSpEnZ0lBNlqKXv7CuTUYCS1pmtEPgwJysQTMUZf7tu5MR0cQ+hY/AlyQ9iKrQAMhHklqZslaisi8VsnoIqH56vfTyyUwUQXrFNc41qG5zZNsXu/NI79JOo7qTvcFHQT/k5cTadbKTxY+9c5eh+nF3JR7zEa2BDDfdQRLNvy4DTSyxdYXdsAk/YPU+JdWI+8ELaa0SuAuNzr5fEkD6NDSG2A==Request Info:&#123;"K":"NAVADHCNP2OIDV46", "DI":"Y2eJk9vrvfGudPG7Mbdn", "P":"MAC"&#125;Response Info:&#123;"K":"NAVADHCNP2OIDV46","DI":"Y2eJk9vrvfGudPG7Mbdn","N":"DoubleLabyrinth","O":"DoubleLabyrinth","T":1537630251&#125;License:oyoMYr9cfVGXeT7F1dqBwHsB/vvWj6SUL6aR+Kzb0lm5IyEj1CgovuSq+qMzFfx+oHMFaGKFg6viOY2hfJcrO2Vdq0hXZS/B/Ie3jBS2Ov37v8e3ufVajaH+wLkmEpLdxppCVLkDQjIHYR2IPz5s/L/RuWqDpEY4TPmGFF6q+xQMnqQA3vXPyG+JYMARXLruY1gCDLN30v3DpyOeqKmFjUqiHK5h8s0NYiH2OpMyaCpi12JsF23miP89ldQp3+SJ8moo0cNGy7sFp2gX9ol2zVoo7qxfYlLl03f7CALJ6im0sx4yBsmlzFDdvpQUbXk8YZ5rT4LML2Fx6Wgnnklb5g==如果不出意外，你会得到一个看似用Base64编码的激活码。直接复制它，并把它粘贴到Navicat的手动激活窗口，最后点激活按钮。如果没什么意外的话应该能成功激活。简化版本navicat15.0.14（更高版本已经不能使用这个注册机了）及对应keygen安装navicat后，使用终端cd到keygen所在目录，执行：1./navicat-patcher /Applications/Navicat\ Premium.app/在生成（总是信任）证书后，依次执行：1codesign -f -s Navicat /Applications/Navicat\ Premium.app/Contents/Frameworks/libcc-premium.dylib1codesign -f -s Navicat /Applications/Navicat\ Premium.app/接下来使用 navicat-keygen 来生成 序列号 和 激活码：1./navicat-keygen ./RegPrivateKey.pem复制其中的 Serial number下的值断开网络 并打开 Navicat找到注册窗口，填入注册机给你的序列号（ Serial number），然后点击激活按钮。Navicat会询问你是否手动激活，点击手动激活在手动激活窗口你会得到一个请求码，复制它并把它粘贴到keygen里连按至少两下回车结束输入你会得到一个 Activation Code，复制它，并把它粘贴到Navicat的手动激活窗口，最后点激活按钮。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS使用过程中的一些小技巧]]></title>
    <url>%2Fp%2F4048823559%2F</url>
    <content type="text"><![CDATA[调整Launchpad的图标大小Mac 上启动太默认的太大，单页显示的内容太少，调节 Launchpad(启动台) 的图标大小，让它看起来更舒服。三行终端指令：先调整每列显示多少个1defaults write com.apple.dock springboard-rows -int 7再调整每行显示多少个1defaults write com.apple.dock springboard-columns -int 8重置一下1defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock效果删除Launchpad内无效图标有时候我们删除完一个应用之后，启动台内还回存留着一个无效的图标，以下就教你如何删除它。找到com.apple.dock.launchpad文件夹打开一个folder，按command+shift+G，在前往当中输入地址/private/var/folders，然后在里边自己尝试找到com.apple.dock.launchpad这个文件夹。大概是这样一个路径：/private/var/var/folders/.../0/com.apple.dock.launchpad省略号处大家都不一样，比如我的路径是：/private/var/var/folders/g7/st6bnhxn2_b9vs3lrm9z3rc00000gn/0/com.apple.dock.launchpad所以慢慢找，总之最后找到名为com.apple.dock.launchpad的文件夹。找到db文件并在终端中cd到该文件，然后输入：1sqlite3 db "delete from apps where title='应用名称';"&amp;&amp;killall Dock比如图中我要删除的图标名为Yoink对文件设置显示/隐藏对于macOS，文件夹也是一种文件，所以此方法也可以用来显示/隐藏文件夹。在finder内查看隐藏文件/关闭显示隐藏文件的快捷键cmd+shift+.显示1cnflags nohidden (文件路径)隐藏1cnflags hidden (文件路径)允许从任意来源下载的应用macOS High Sierra之后，好像加入了新的安全机制，安装的应用会被系统进行安全性确认。通过设置可以关闭这个确认的过程，即允许从任意来源下载的应用运行。在终端（系统自带终端，我在iterm2里运行好像不行）输入：1sudo spctl --master-disable之后会要求你输入密码，输入即可。完成后，在系统偏好设置里可以看到：如要关闭这个更改，在终端输入：1sudo spctl --master-enable]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac新手值得装机的软件]]></title>
    <url>%2Fp%2F3535319776%2F</url>
    <content type="text"><![CDATA[开始之前​ 对于刚从Windows转到macOS的同学来说，除了陌生的操作环境外，陌生的软件生态也困扰着我们。Mac端的App Store远不如iOS端的简单易用，很多常用的软件往往要单独去网上下载；另一方面，Mac App Store里的软件往往费用高昂。我刚入手Mac的时候，逛了好几天知乎少数派等平台，从大量的推荐中罗列出以下清单，供大家参考。​ 注意清单含个人喜好成分，提供的参考价值更大清单中出现的一些看似操作难度大的步骤实际上并不难，按照教程操作即可清单中若出现的违法行为，请通知我，必将马上更改包管理工具​ 所谓的包管理工具，通俗的说是应用市场（当然不能划等号）。​ 因为Mac App Store的一些缺点，我们不得不从网上下载需要的软件。然而，从网络下载的软件要么可能被篡改，要么无法彻底删除（因为Mac系统的文件管理系统），会产生一些垃圾文件，因此，需要一个包管理工具来对软件或套件进行管理。关于包管理工具会写的比较详细，不是因为它有多难，而是因为它重要且有用### Homebrew ​ `Homebrew`是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 ​ 援引[Homebrew官方](https://link.jianshu.com?t=http%3A%2F%2Fbrew.sh%2F)的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。[1](#homebrew)（提一句，现在不叫OSX了，叫macOS）注意`$`不包含在输入的命令内* 安装homebrew 打开终端，输入以下代码，稍等片刻，输入密码，等待安装完成1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"* 验证安装是否成功 输入查看版本信息，有返回结果则安装成功1brew -v* 卸载 打开终端，输入以下代码，稍等片刻，输入密码，等待卸载完成删除homebrew时也会删除通过brew命令安装的软件/套件，请警慎操作1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)"* 基本使用123456789101112//安装任意包$ brew install &lt;packageName&gt;//示例$ brew install wget//卸载任意包$ brew uninstall &lt;packageName&gt;//查询可用包$ brew search &lt;packageName&gt;//查看安装列表$ brew list//查看任意包信息$ brew info &lt;packageName&gt;* 其他1234//更新homebrew$ brew update//查看homebrew帮助信息$ brew -h一些情况下，使用homebrew会提示权限不足（然而我不知道为什么没遇到过），请在命令前加入`sudo`前缀来执行,例如（更新brew）：`sudo brew update`### Homebrew Cask ​ Homebrew Cask 是 Homebrew 的扩展，借助它可以方便地在 macOS 上安装图形界面程序，即我们常用的各类应用。 ​ Homebrew 中文含义为自制、自酿酒，Cask 中文含义为桶、木桶，桶装酒是一种成品，也就是说每一个 `homebrew cask` 都可以直接使用的[2](#homebrew-cask)。 ​ 比如 Atom 的 Cask 名称为 atom，那么就可以使用如下命令安装：`brew cask install atom`你也可以通过`brew cask install`的命令来安装cask包，因为最新版本的Homebrew已经集成了cask。cask的命令几乎和homebrew相同，只要类似的加上`cask`，如下图：如果没有安装cask或相关命令无效，请执行:`brew tap caskroom/cask`## 终端配置及美化 ​ macOS不同于win，使用过程中借用终端(terminal)来辅助操作的机会很多。~~试问谁会不喜欢一个美观实用的终端来提升幸福感呢？~~**好吧不需要的可以跳过这个部分**。 ​ 如果你需要的话请看下面这个烂大街的配置：`iTerm2+On My Zsh+Solarized Dark theme+Monaco for Powerline+ys/Powerlevel9k`* 效果 * 安装iTerm21brew cask install iterm2*具体的美化教程会另外写篇教程*（逃（毕竟这篇文章主要是用来推荐软件的 ## 网络相关配置 ### ShadowsocksX-NG-R8 这个不多说，我选择了R8 * 安装方法1brew cask install shadowsocksx-ng-r### HoRNDIS ​ 当我之前用win的时候，喜欢让我的安卓机通过usb连接（USB共享网络）来给电脑开热点（其实这时候相当于连网线了），这样既能给我的手机充电，网速又比直接连热点快且稳。但是Mac和Android并不能直接这样搭配，而HoRNDIS就是一个能让Mac连上安卓设备通过usb共享网络的驱动。需重启 * 安装方法1brew cask install horndis## 压缩解压软件 ​ Mac自带了归档实用工具，但功能有限，且只支持`.zip`格式的文件。这也就意味着，你不能打开别人传给你的`.rar`格式的压缩包，因此需要一款兼容多种压缩格式的压缩解压软件。 ​ 这里不得不提的是，在Mac平台上，就算你能解压某些格式的压缩包，但当**文件名**中有中文字符的时候，解压后会产生乱码（这**好像**是因为Mac和win中文字符集不同，具体不细说了）。 ​ 而我们在App Store上搜索`压缩`或者`解压`的结果： ​本来想放张截图的，但感觉冲击力不够 简单来说，是一系列收费昂贵/便宜却有广告/免费但有试用期的软件，光光压缩解压软件这块，我就搜了个吧小时，最后才得出来下面这个廉价而有效的结论。### Keka ​ 怎么说呢，备受好评。只要是[Keka](https://www.keka.io/en/)出现的地方，一定都是推荐的，除了有些人却嫌它图标丑...Keka图标明明这么萌！而且它支持多种压缩解压格式（当然包括.rar），准确率高，没有广告。安装方法App Store收费12元，但是，官网下载免费！你可以直接在Keka官网下,也可以通过Homebrew下。1brew cask install kekaThe Unarchiver​ 其实一般情况下Keka足以胜任压缩和解压的工作，但我因为十分担心解压出现的乱码问题，所以又特意下载了这个Mac端解压之王——The Unarchiver。它最大的优点就是，稳！如果说Keka能保证98%的文件解压时不发生乱码，那The Unarchiver就能保证99.99%以上不发生乱码。（以上数据纯属捏造）​ The Unarchiver只能解压，免费，快，无广告，支持格式超多，体积小，因此我额外下载了它作为补充。安装方法App Store直接下载即可音视频播放软件​ 其实这方面我需求不是很大，大多数看视频的任务都能在网页端完成因此在粗略的浏览后，我选择了——IINA。IINA​ IINA for Mac是一款开源视频播放器。IINA基于 mpv(一个神器级别的开源解码工具)，为最新 Mac 系统而生，支持 Touch Bar、兼容 MPV 脚本、几乎支持所有格式、网络播放，网上评价它“最原生，最优雅”。我安装它时(2019年初），它刚刚发布了第一个正式版。安装方法1brew cask install iina通过配置youtube-dl，你可以实现一些视频网站的URL播放。安装youtube-dl：1brew insatll youtube-dl安装完成后运行：1brew link youtube-dl可以链接到该处。然后你可以运行：1which youtube-dl查询新的路径。将该路径复制到IINA的偏好设置-&gt;网络-&gt;youtube-dl-&gt;启用youtube-dl-&gt;自定义youtube-&gt;dl路径中：/usr/local/bin ，重启IINA即可。youtube-dl经常更新，所以你要在必要的时候检查更新。腾讯视频​ 纯属个人喜好​ 不得不说，腾讯在Mac端的产品真的比win端的良心太多了。腾讯视频 for Mac没有任何一条广告，不管是应用内还是播放视频时，而且免费提供蓝光，在加上我自己的vip，美滋滋。如果这篇火了腾讯请给我打钱安装方法App Store直接下载即可Permute视频格式转化工具。七天试用，付费，建议淘宝。安装方法1brew cask install permute文档工具未完全确定WPS 2019​ 也是一款良心产品，为什么这么说呢，没有广告（好吧我对良心的要求好低啊）。那么为什么这么良心呢？因为腾讯爸爸投了金山。两份广告费​ office软件最出名的当然是Microsoft Office套件，而Mac端具说体验不怎么好。我还没有使用过，但使用成本太高。不过都说Microsoft Office for Mac不完美兼容win端文件，你看吧，虽然wps也不兼容，但是人家不要钱啊。另一方面，而苹果自带的office工具又无法打开我win端遗留下来的文件，而且我也懒得去用。因此，我选择了WPS，日常使用以及足够了。​ 免费，没有广告，有云端，日常足够，所以就是它了。安装方法App Store直接下载即可PDF Expert *想要但买不起系列* ​ 一款所有（买得起的）人都在推荐的pdf软件，App Store标价518¥…应该很好用，但我买不起…MWeb​ 想要但买不起系列​ MWeb是一个markdown工具，因为我使用markdown主要是用来写笔记，因此MWeb的文档库，标签，图床功能更适合我。​ 最后在某个论坛找了个破解版。Typora​ 这是一个markdown工具，WMeb的补充品，喜欢它的即时渲染。图床功能需要依靠另一款软件——iPic（订阅制），所以我没用它的图床。实用软件QQ&amp;微信​ 不多说，必备。还是那句话，腾讯系的Mac端产品很良心。安装方法App Store直接下载即可Google Chrome​ win端的遗留，大量保存在云上的门户账号密码，书签等让我把它下了下来；丰富的插件是我继续使用它的理由;配合谷歌体验更佳。安装方法1brew cask install google-chromeSpark​ 邮箱工具。我理想的邮箱工具更需要像小米邮箱客户端这样，支持多种邮箱，并且收件延迟低。选择Spark纯属是矮个里面拔高个，其他的更不好用。Spark唯二的缺点是，收件延迟还是高（相比其他不高），不支持126邮箱和学校邮箱。安装方法1brew cask install spark鼠须管输入法​ 因为自带的输入法不支持小鹤双拼+不想用搜狗，所以在几个支持小鹤的输入法中选择了这个。你可以根据自己的需要更改它的配置文件，也可以直接clone Rime，将文件覆盖至Library/Rime（输入法设置处点击用户设置即打开对应文件夹。覆盖至后，在输入法设置处点击重新部署即设置成功。滴答清单​ To do管理软件，我选择它是因为它是不花钱的里面体验最好的，而且各平台均有客户端。订阅制的价格让我对付费持观望态度。如果付费，建议在安卓端购买，能便宜点。安装方法App Store免费下载网易云音乐​ 对我来说足够，开了会员，不想用iTunes。安装方法App Store下载也可以。1brew cask install neteasemusic下载软件axel​ 一个命令行式的多线程下载工具。安装方法1brew install axel使用方法1234//axel -n 30(建议维持在几十，越高下载线程数越多,需要性能也越高)+(链接)//示例：axel -n 30 https://services.gradle.org/distributions/gradle-4.2-all.zip//下载结果保存在命令执行时的路径下downloader+chrome插件​ 使用downloader配合Google chrome的插件，就能够以高速正常速度下载百度云资源。安装方法自行百度搜索相关资源Free Download Manager​ 据说很好用，在试用中，觉得一般。对于小文件，我设置了浏览器内下载。安装方法1brew cask install free-download-manager剪切板管理软件​ 对于我这种面向cmd+c/cmd+v编程的人来说，剪切板管理必不可少。Paste​ 界面清爽精致好用，管理方便。在需要大量复制黏贴操作的时候，能够缓解需要马上把剪切板内容粘贴掉的紧张感，还能更有效率的获取曾经的内容。​ 免费使用7天，淘宝购买激活码省一半钱，但不是自己账户，现在感觉不如直接App Store买。安装方法1brew cask install pastePopClip​ 长按选中型工具，有大量扩展（官网有一两百个），与iterm2，词典等搭配使用效果更佳。App Store付费30¥，相信我完全值得。安装方法App Store付费下载Yoink​ 可以买但没那么必要​ Yoink 这类工具往往被统称为“shelf”（架子）类 app。顾名思义，它们的作用就是充当一个临时的「置物架」，临时存放我们想要收集却又未确定归属的内容。当你要在多个文件或多段文本之间进行处理时，它能帮你在提高效率的同时，缓解你的紧张感。3​ App Store有阉割版供试用，可能是我现在需要处理的文件不多，好看是好看，有用是有用，但正式版50¥让我觉得没必要了。安装方法App Store下载体验版和正式版效率工具​ 不知道为什么，自从入手Mac之后，我就痴迷各种效率工具，另一方面Mac端的效率工具是真的丰富还好用。这些效率工具加上Mac电脑特性（特指系统、快捷键、触摸板），真的带给了我使用win时没有的体验。​ 当然，有一些效率工具是为了弥补Mac的缺点，比如Homebrew。BetterTouchTool​ BetterTouchTool，业界简称BTT。BetterTouchTool 是一款专为Mac用户开发的 窗口管理/Trackpad(触控板)/Magic Mouse(苹果鼠标)/Keyboard(键盘)/TouchBar功能增强制作的软件。4​ 这款软件不但可以设置全局的手势/快捷键/TouchBar ，还可以给不同的应用定义不同的姿势。功能多，上手快。可试用45天，官网付费140+¥，淘宝可便宜一半。安装方法1brew cask install bettertouchtoolCheatSheet​ 辅助记忆快捷键的一个小软件，给新手记忆macOS和Mac App繁多应用的，长按cmd可以唤出。​ 其实我安装之后机会没用过…安装方法1brew cask install cheatsheetAlfred​ Mac神器之一，然而我使用的免费版，仅使用其搜索功能，但其实它功能极其丰富。​ Alfred 形态上类似 macOS 自己的 Spotlight（已改名为 “聚焦”），因此像 Spotlight 有个快捷键作为入口一样，Alfred 也有，快捷键可随意设置，最好不要跟其他软件或者 macOS 系统本身的一些主要快捷键冲突，这里我把它设置成了短按两次“cmd”，容易记又没什么别的软件用这个快捷键所以不会冲突。​ Alfred的强大之处在于付费的Powerpack，然而单用户终身版价格35镑(rmb多少自己换算去吧)…安装方法1brew cask install alfred一些小工具Adguard​ 一款应该是才出的广告屏蔽软件，全平台，客户端付费，Google Chrome的插件免费。效果还行。安装方法Google Chrome插件商店下载即可DictUnifiert​ 将SarDict的词库转化成词典可以用的词库，用于拓展Mac默认应用词典。这是我在扩展PopClip的词典插件功能时使用的，用完即删。安装方法1brew cask install dictunifierGo2Shell​ 在finder的工具栏添加部件，使其能够在任意位置打开terminal(可配置打开iterm2)。安装方法1brew cask install go2shell2.3 版本的 Go2Shell 图标是打不开终端的，它只会默认打开配置窗口。要去路径为：/Applications/Go2Shell.app/Contents/MacOS 将名为 Go2ShellHelper.app 的图标拖到 Dock 栏上。拖完再从Dock栏`remove`即可。 不过有些路径不管怎么都是无法通过这个方法打开的。HandShaker​ 锤科出品，让你的Mac通过网络或数据线管理你安卓机上的文件。安装方法1brew cask install handshaker编程软件​ 这段是写给自己的​ 作为一个程序员，我的装机软件有____Xcode​ 其实我不用Xcode，但安装很多东西的时候会用到它，所以就下了。安装方法App Store直接下载IntelliJ IDEA​ 作为一个Java程序员，必不可少。安装方法1brew cask install intellij-ideaAndroid Studio​ 学习安卓应用开发，仰慕谷歌之风。安装方法1brew cask install android-studioVisual Studio Code​ 可能是所有神级编辑器里我用的最熟的了，有关配置有机会单开教程说明。安装方法1brew cask install visual-studio-codeGitHub Desktop​ 我没有特别的需求，就用官方的Desktop了。安装方法[GitHub官方](https://desktop.github.com/)下载Navicat Permium​ 数据库的图像化管理软件，支持多种数据库，正版价格高昂（几k），但可以破解激活…（破解方法可以百度或见我的另一篇文章:Navicat Premium for Mac破解教程）安装方法1brew cask install navicat-permium通过brew安装的版本是英文版，如需中文版，可以至官网下载MySql8.0以上版本最好更改加密方式1234//"new pswd"即你要设置的新密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'new pswd' PASSWORD EXPIRE NEVER;ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'new pasd';FLUSH PRIVILEGES;FinalShell​ ssh软件，算是推荐的比较多的一款，使用了一下，感觉还行安装方法1curl -o finalshell_install.sh www.hostbuf.com/downloads/finalshell_install.sh;chmod +x finalshell_install.sh;sudo ./finalshell_install.sh卸载安装目录：/Applications/finalshelldata安装路径：/usr/lib/finalshelldata/配置文件路径：/home/$USER/.finalshell/网易MuMu​ 虚拟机，我用来测试app（因为AS自带的不能输入中文…)安装方法[MuMu模拟器官网](https://mumu.163.com/)下载参考链接简书：Mac终端软件安装利器：Homebrew简书：再谈 Homebrew Cask 在 macOS 上的应用安装少数派：临时文件的中转站：Yoink for iOS 测评简书：Mac神器-BTT(BetterTouchTool)不完全教程]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo下的Mrakdown语法简册]]></title>
    <url>%2Fp%2F1136132855%2F</url>
    <content type="text"><![CDATA[这篇文章用来记录平时常用的一些Markdown（以下简称MD）语法，省得我常常要去百度。Markdown标准语法参考：高鸿祥，iTimeTraveler对于一些非常常用的语法将不再记录。字体加粗，一对**号**加粗**加粗斜体，一对*号*斜体*斜体斜体加粗，三对*号***斜体加粗***斜体加粗删除线，两对~号~~删除线~~删除线下划线&lt;u&gt;下划线&lt;/u&gt;下划线引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;示例123&gt;这是1层引用&gt;&gt;这是2层引用&gt;&gt;&gt;&gt;&gt;这是5层引用效果这是1层引用这是2层引用这是5层引用分割线三个及以上的-或者*示例12345-------*******&lt;hr&gt;或&lt;hr/&gt;效果—-图片语法1234![alt](图片地址 "title")alt：显示在图片下面的文字，相当于对图片内容的解释。title：是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加或者：1234567&lt;div align=位置参数&gt;&lt;img width="宽" height="高" src="图片地址" alt="XXX"/&gt;&lt;br&gt;图片说明&lt;/div&gt;这种格式会被html解释位置参数：left, right, center宽，高：300px图片说明：显示在图片正下方的文字示例12![Intellij Idea](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/IntelliJ_IDEA_Logo.svg/128px-IntelliJ_IDEA_Logo.svg.png 'wiki上的intellij idea图标')或者：12// 宽度和高度可以根据显示需要设置绝对值和百分比&lt;div align=center&gt;&lt;img width="200px" height="200px" src="https://www.keka.io/img/Keka-512x512.png" alt="Keka"/&gt;&lt;br&gt;Keka图标&lt;/div&gt;效果Keka图标超链接语法12[超链接名](超链接地址 "超链接title")title可加可不加或者：123&lt;a href="超链接地址" target="_blank"&gt;超链接名&lt;/a&gt;_blank参数能支持链接在新页面打开示例123[百度](http://baidu.com)&lt;a href="https://somelou.xyz" target="_blank"&gt;我的首页&lt;/a&gt;效果百度我的首页锚点语法1234初始地：[显示文字](#目的id)目的地：&lt;span id=&quot;XXX&quot;&gt;显示文字&lt;/span&gt;示例1234初始地：[font](#whereFont)目的地：&lt;span id=&quot;whereFont&quot;&gt;字体&lt;/span&gt;效果font目的地设置在了开头“字体”处角标语法1234上角标：&lt;sup&gt;文字&lt;/sup&gt;下角标：&lt;sub&gt;文字&lt;/sub&gt;示例1234上角标：&lt;sup&gt;上角标&lt;/sup&gt;下角标：&lt;sub&gt;下角标&lt;/sub&gt;效果上角标上角标下角标下角标表格语法12345678910111213表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注1：原生的语法两边都要用 | 包起来。此处省略注2：表格不能产生缩进，否则hexo无法渲染示例12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟效果姓名技能排行刘备哭大哥关羽打二哥张飞骂三弟diff代码块示例1234```diff+ add info- delete info​123456* 效果 ```diff + add info - delete info流程图不是所有markdown编辑器都支持示例12345678910(```)flowst=&gt;start: 闹钟响起op=&gt;operation: 与床板分离cond=&gt;condition: 分离成功?e=&gt;end: 快乐的一天st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op(```)效果12345678st=&gt;start: 闹钟响起op=&gt;operation: 与床板分离cond=&gt;condition: 分离成功?e=&gt;end: 快乐的一天st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op时序图不是所有markdown都支持示例12345(```)sequence李雷 -&gt; 韩梅梅: Hello 梅梅, How are you?Note right of 韩梅梅: 韩梅梅心想韩梅梅 --&gt; 李雷: I&apos;m fine, thanks, and you(```)效果123李雷 -&gt; 韩梅梅: Hello 梅梅, How are you?Note right of 韩梅梅: 韩梅梅心想韩梅梅 --&gt; 李雷: I&apos;m fine, thanks, and youHexo的语法参考：hiekay，ChristmasFront-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hellodate: 2018/2/9 22:16:13---以下是我常用的参数，您可在模板中使用这些参数值并加以利用。参数描述默认值title标题date建立日期文件建立日期permalink覆盖文章网址字段top文章排序（可用于置顶）tags标签（不适用于分页）categories分类（不适用于分页）keywords文章关键字(用于SEO)typora-root-url设置文章内图片绝对路径description文章描述image首页展示图片链接comments开启文章的评论功能true以下是我的post模板。12345678910111213141516171819---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;permalink:categories:tags: []keywords: []typora-root-url: /Users/xxx/Docs/Blog/somelou.github.io/static/images/&#123;&#123;permalink&#125;&#125;/description: image: ---&lt;!-- more --&gt;##&#123;% qnimg test/demo.png title:图片标题 alt:图片说明 %&#125;####&lt;hr/&gt;主题自带样式note标签首先要在站点配置文件中配置如下信息：1234567891011121314151617181920212223# Note tag (bs-callout).note:# Note tag style values:# - simple bs-callout old alert style. Default.# - modern bs-callout new (v2-v3) alert style.# - flat flat callout style with background, like on Mozilla or StackOverflow.# - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3# Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).# Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0示例1234567891011121314//default灰色样式调用方式 &lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt;//primary紫色样式调用方式 &lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt;//success绿色样式调用方式 &lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt;//info蓝色样式调用方式 &lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt;//warning橙色样式调用方式 &lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt;//danger红色样式调用方式 &lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;//danger no-icon红色无图标样式调用方式 &lt;div class="note danger no-icon"&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt;效果defaultprimarysuccessinfowarningdangerdanger no-icon文本居中示例123456&#123;% cq %&#125;人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！&#123;% endcq %&#125;或者：1&lt;blockquote class="blockquote-center"&gt;这个城市的灯火辉煌，与你无关&lt;/blockquote&gt;效果人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！这个城市的灯火辉煌，与你无关自定义数字块在~/themes/next/source/css/_custom/custom.styl中添加下列代码：12345678910// 自定义的数字块span#inline-toc &#123; display: inline-block; border-radius: 80% 100% 90% 20%; background-color: rgb(227, 242, 253); color: #555; padding: 0.05em 0.4em; margin: 2px 5px 2px 0px; line-height: 1.5;&#125;示例1&lt;span id="inline-toc"&gt;1.&lt;/span&gt;效果1.自定义颜色块标签同样在~/themes/next/source/css/_custom/custom.styl中添加下列代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 颜色块-黄span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e;&#125;// 颜色块-黑span#inline-black &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: black;&#125;// 颜色块-绿span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb;&#125;// 颜色块-红span#inline-red &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #df3e3e;&#125;语法1&lt;span id="inline-颜色"&gt;颜色块标签内容&lt;/span&gt;示例1&lt;span id="inline-yellow"&gt;yellow&lt;/span&gt;&lt;span id="inline-black"&gt;black&lt;/span&gt;&lt;span id="inline-green"&gt;green&lt;/span&gt;&lt;span id="inline-blue"&gt;blue&lt;/span&gt;&lt;span id="inline-red"&gt;red&lt;/span&gt;&lt;span id="inline-purple"&gt;purple&lt;/span&gt;效果yellowblackgreenblueredpurple自定义块级框在~/themes/next/source/css/_custom/custom.styl中添加下列代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// 左侧边框红色块级p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb;&#125;示例1&lt;p id="div-border-left-red"&gt;文字信息&lt;p&gt;效果比hexo内置的note标签要稍微好看点上侧块共5个类型red,yellow,green,blue,purple侧边块也是五个类型，分左右两种七牛显示图片我的图片管理地址：七牛图片管理示例1&#123;% qnimg md-grammer/fu.jpg title:&apos;支付宝沾福气&apos; alt:一张七牛演示图片 %&#125;或者：1&lt;div align=center&gt;初始界面&lt;img width=400px height=300px src="https://cdn.somelou.xyz/static/images/md-grammer/fu.jpg" alt="一张七牛演示图片"/&gt;&lt;/div&gt;效果法二参考链接高鸿祥：Markdown基本语法hiekay：hexo 创建文章、标签、分类的Front-matteriTimeTraveler：表格无法正确显示Christmas：Hexo_Next_博客搭建记]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的使用简册]]></title>
    <url>%2Fp%2F1243066710%2F</url>
    <content type="text"><![CDATA[这是基于 Hexo的站点，查看 官方文档 获得更多信息。 Hexo的反馈地址：troubleshooting 或 GitHub。常用命令新建博文1234$ hexo new "My New Post"or$ hexo n "My new post"//有空格时必加引号More info: Writing本地测试123$ hexo serveror$ hexo sMore info: Server编译网页123$ hexo generateor$ hexo gMore info: Generating发布到服务器123$ hexo deployor$ hexo dMore info: Deployment清除编译内容123$ hexo cleanor$ hexo c七牛图片同步123$ hexo qiniu syncor$ hexo qiniu s]]></content>
      <categories>
        <category>站点</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的SSM框架实例]]></title>
    <url>%2Fp%2F2622962694%2F</url>
    <content type="text"><![CDATA[项目地址参照文章系统说明开发环境编译器：Intellij idea（jdk1.8.0）数据库：mysql服务器：Tomcat(9.0）框架SSM框架Spring+SpringMVC+MyBatis项目框架包结构详细说明java包（Source Root）pojo：存放自定义的java类。如：paper类，user类，book类等，每个类的属性设为private，并提供public属性的getter/setter方法让外界访问；service：定义接口，包含系统所提供的功能。（service包下再新建impl包用来实现接口上一个包的接口类）；dao：定义接口，包含与数据库进行交互的功能；controller：控制器，负责接收页面请求，转发和处理；resources包Directory：“mapper”（用于存放xxxMapper.xml文件）和“spring”（用于存放spring-xxx.xml配置文件）；userMapper.xml：mybatis框架mapper代理开发配置文件；spring-dao.xml：spring-mybatis整合配置文件;spring-mvc.xml：spring mvc配置文件, 自动扫描控制器，视图模式，注解的启动；spring-service.xml：扫描注解，配置事务器；文件：“jdbc.properties”：mysql数据库配置文件；“log4j.properties”：日志输出配置文件；“mybatis-config.xml”：mybatis框架配置文件；web-inf目录新建“jsp”包（存放xxx.jsp显示界面）：addUser.jsp：新增用户页面；allUser.jsp：主操作界面；updateUser.jsp：更新用户界面。项目功能初始界面(index.jsp)有一个提示“点击进入用户管理页面”的超链接，指向主操作界面(allUser.jsp)。主操作界面(allUser.jsp)默认显示所有用户信息，并有“查询”(findUser())和“新增”(addUser.jsp)功能按钮。“查询”用户默认查询全部（因数据库内容较少，不采用分页功能），可根据条件(userName)输入值(name)进行模糊查询，查询结果返还显示到本页面中(allUser.jsp)查询结果根据每条记录主键附加“更改”(updateUser.jsp)和“删除”(/user/del)链接，在超链接里传递用户名(user.userName)。新增用户(addUser.jsp)成功则返回主操作界面(allUser.jsp)。更改用户指向“更改用户”(updateUser.jsp)界面，在此显示想要更改用户的已注册信息（用户名不可更改）(readonly),信息更改完成后进行提交。更改成功返回主操作界面(allUser.jsp)。删除用户在执行“删除”(deleteUser())后提示“删除成功”并返回查询界面(findUser.jsp)，否则提示“删除失败”并返回查询界面。项目运行效果初始界面主操作界面]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>demo</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
</search>
